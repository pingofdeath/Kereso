<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
				<meta name="keywords" content="Linked list,2004,2005,Abstract data type,Allen Newell,Amortized analysis,Append,April 4,Array,Artificial intelligence,Associative array" />
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (English)" />
		<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html" />
		<title>Linked list - Wikipedia, the free encyclopedia</title>
		<style type="text/css" media="screen, projection">/*<![CDATA[*/
			@import "/skins-1.5/common/shared.css?99";
			@import "/skins-1.5/monobook/main.css?99";
		/*]]>*/</style>
		<link rel="stylesheet" type="text/css" media="print" href="/skins-1.5/common/commonPrint.css?99" />
		<!--[if lt IE 5.5000]><style type="text/css">@import "/skins-1.5/monobook/IE50Fixes.css?99";</style><![endif]-->
		<!--[if IE 5.5000]><style type="text/css">@import "/skins-1.5/monobook/IE55Fixes.css?99";</style><![endif]-->
		<!--[if IE 6]><style type="text/css">@import "/skins-1.5/monobook/IE60Fixes.css?99";</style><![endif]-->
		<!--[if IE 7]><style type="text/css">@import "/skins-1.5/monobook/IE70Fixes.css?99";</style><![endif]-->
		<!--[if lt IE 7]><script type="text/javascript" src="/skins-1.5/common/IEFixes.js?99"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
		
		<script type= "text/javascript">/*<![CDATA[*/
var skin = "monobook";
var stylepath = "/skins-1.5";
var wgArticlePath = "/wiki/$1";
var wgScriptPath = "/w";
var wgScript = "/w/index.php";
var wgServer = "http://en.wikipedia.org";
var wgCanonicalNamespace = "";
var wgCanonicalSpecialPageName = false;
var wgNamespaceNumber = 0;
var wgPageName = "Linked_list";
var wgTitle = "Linked list";
var wgAction = "view";
var wgRestrictionEdit = [];
var wgRestrictionMove = [];
var wgArticleId = "18167";
var wgIsArticle = true;
var wgUserName = null;
var wgUserGroups = null;
var wgUserLanguage = "en";
var wgContentLanguage = "en";
var wgBreakFrames = false;
var wgCurRevisionId = "157604727";
/*]]>*/</script>
                
		<script type="text/javascript" src="/skins-1.5/common/wikibits.js?99"><!-- wikibits js --></script>
		<script type="text/javascript" src="/w/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook"><!-- site js --></script>
		<style type="text/css">/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Common.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
@import "/w/index.php?title=MediaWiki:Monobook.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
@import "/w/index.php?title=-&action=raw&gen=css&maxage=2678400";
/*]]>*/</style>
		<!-- Head Scripts -->
		<script type="text/javascript" src="/skins-1.5/common/ajax.js?99"></script>
<style type="text/css">/*<![CDATA[*/
.source-c {line-height: normal;}
.source-c li {line-height: normal;}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for c
 * CSS class: source-C, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-C .de1, .source-C .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-C  {}
.source-C .head {}
.source-C .foot {}
.source-C .imp {font-weight: bold; color: red;}
.source-C .ln-xtra {color: #cc0; background-color: #ffc;}
.source-C li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-C li.li2 {font-weight: bold;}
.source-C .kw1 {color: #b1b100;}
.source-C .kw2 {color: #000000; font-weight: bold;}
.source-C .kw3 {color: #000066;}
.source-C .kw4 {color: #993333;}
.source-C .co1 {color: #808080; font-style: italic;}
.source-C .co2 {color: #339933;}
.source-C .coMULTI {color: #808080; font-style: italic;}
.source-C .es0 {color: #000099; font-weight: bold;}
.source-C .br0 {color: #66cc66;}
.source-C .st0 {color: #ff0000;}
.source-C .nu0 {color: #cc66cc;}
.source-C .me1 {color: #202020;}
.source-C .me2 {color: #202020;}

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
</style>	</head>
<body  class="mediawiki ns-0 ltr page-Linked_list">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
				<h1 class="firstHeading">Linked list</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<table class="infobox" style="font-size: smaller;">
<tr>
<th style="font-size:larger; background: #ccc;">Linear <a href="/wiki/Data_structures" title="Data structures">data structures</a></th>
</tr>
<tr>
<td>
<p><a href="/wiki/Array" title="Array">Array</a><br />
<a href="/wiki/Deque" title="Deque">Deque</a><br />
<strong class="selflink">Linked list</strong><br />
<a href="/wiki/Queue_%28data_structure%29" title="Queue (data structure)">Queue</a><br />
<a href="/wiki/Stack_%28data_structure%29" title="Stack (data structure)">Stack</a><br /></p>
</td>
</tr>
</table>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, a <b>linked list</b> is one of the fundamental <a href="/wiki/Data_structure" title="Data structure">data structures</a>, and can be used to implement other data structures. It consists of a sequence of <a href="/wiki/Node_%28computer_science%29" title="Node (computer science)">nodes</a>, each containing arbitrary data <a href="/wiki/Field_%28computer_science%29" title="Field (computer science)">fields</a> and one or two <a href="/wiki/Reference" title="Reference">references</a> ("links") pointing to the next and/or previous nodes. The principal benefit of a linked list over a conventional <a href="/wiki/Array" title="Array">array</a> is that the order of the linked items may be different from the order that the data items are stored in memory or on disk, allowing the list of items to be traversed in a different order. A linked list is a self-referential datatype because it contains a pointer or link to another datum of the same type. Linked lists permit insertion and removal of nodes at any point in the list in constant time,<sup id="_ref-0" class="reference"><a href="#_note-0" title="">[1]</a></sup> but do not allow <a href="/wiki/Random_access" title="Random access">random access</a>. Several different types of linked list exist: singly-linked lists, doubly-linked lists, and circularly-linked lists.</p>
<p>Linked lists can be implemented in most languages. Languages such as <a href="/wiki/Lisp_programming_language" title="Lisp programming language">Lisp</a> and <a href="/wiki/Scheme_%28programming_language%29" title="Scheme (programming language)">Scheme</a> have the data structure built in, along with operations to access the linked list. Procedural or object-oriented languages such as <a href="/wiki/C_%28programming_language%29" title="C (programming language)">C</a>, <a href="/wiki/C%2B%2B" title="C++">C++</a>, and <a href="/wiki/Java_%28programming_language%29" title="Java (programming language)">Java</a> typically rely on mutable <a href="/wiki/Reference_%28computer_science%29" title="Reference (computer science)">references</a> to create linked lists.</p>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a href="#History"><span class="tocnumber">1</span> <span class="toctext">History</span></a></li>
<li class="toclevel-1"><a href="#Types_of_linked_lists"><span class="tocnumber">2</span> <span class="toctext">Types of linked lists</span></a>
<ul>
<li class="toclevel-2"><a href="#Linearly-linked_list"><span class="tocnumber">2.1</span> <span class="toctext">Linearly-linked list</span></a>
<ul>
<li class="toclevel-3"><a href="#Singly-linked_list"><span class="tocnumber">2.1.1</span> <span class="toctext">Singly-linked list</span></a></li>
<li class="toclevel-3"><a href="#Doubly-linked_list"><span class="tocnumber">2.1.2</span> <span class="toctext">Doubly-linked list</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Circularly-linked_list"><span class="tocnumber">2.2</span> <span class="toctext">Circularly-linked list</span></a>
<ul>
<li class="toclevel-3"><a href="#Singly-circularly-linked_list"><span class="tocnumber">2.2.1</span> <span class="toctext">Singly-circularly-linked list</span></a></li>
<li class="toclevel-3"><a href="#Doubly-circularly-linked_list"><span class="tocnumber">2.2.2</span> <span class="toctext">Doubly-circularly-linked list</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Sentinel_nodes"><span class="tocnumber">2.3</span> <span class="toctext">Sentinel nodes</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Applications_of_linked_lists"><span class="tocnumber">3</span> <span class="toctext">Applications of linked lists</span></a></li>
<li class="toclevel-1"><a href="#Tradeoffs"><span class="tocnumber">4</span> <span class="toctext">Tradeoffs</span></a>
<ul>
<li class="toclevel-2"><a href="#Linked_lists_vs._arrays"><span class="tocnumber">4.1</span> <span class="toctext">Linked lists vs. arrays</span></a></li>
<li class="toclevel-2"><a href="#Doubly-linked_vs._singly-linked"><span class="tocnumber">4.2</span> <span class="toctext">Doubly-linked vs. singly-linked</span></a></li>
<li class="toclevel-2"><a href="#Circularly-linked_vs._linearly-linked"><span class="tocnumber">4.3</span> <span class="toctext">Circularly-linked vs. linearly-linked</span></a></li>
<li class="toclevel-2"><a href="#Sentinel_nodes_2"><span class="tocnumber">4.4</span> <span class="toctext">Sentinel nodes</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Linked_list_operations"><span class="tocnumber">5</span> <span class="toctext">Linked list operations</span></a>
<ul>
<li class="toclevel-2"><a href="#Linearly-linked_lists"><span class="tocnumber">5.1</span> <span class="toctext">Linearly-linked lists</span></a>
<ul>
<li class="toclevel-3"><a href="#Singly-linked_lists"><span class="tocnumber">5.1.1</span> <span class="toctext">Singly-linked lists</span></a></li>
<li class="toclevel-3"><a href="#Doubly-linked_lists"><span class="tocnumber">5.1.2</span> <span class="toctext">Doubly-linked lists</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Circularly-linked_lists"><span class="tocnumber">5.2</span> <span class="toctext">Circularly-linked lists</span></a>
<ul>
<li class="toclevel-3"><a href="#Doubly-circularly-linked_lists"><span class="tocnumber">5.2.1</span> <span class="toctext">Doubly-circularly-linked lists</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1"><a href="#Linked_lists_using_arrays_of_nodes"><span class="tocnumber">6</span> <span class="toctext">Linked lists using arrays of nodes</span></a></li>
<li class="toclevel-1"><a href="#Language_support"><span class="tocnumber">7</span> <span class="toctext">Language support</span></a></li>
<li class="toclevel-1"><a href="#Internal_and_external_storage"><span class="tocnumber">8</span> <span class="toctext">Internal and external storage</span></a>
<ul>
<li class="toclevel-2"><a href="#Example_of_internal_and_external_storage"><span class="tocnumber">8.1</span> <span class="toctext">Example of internal and external storage</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Speeding_up_search"><span class="tocnumber">9</span> <span class="toctext">Speeding up search</span></a></li>
<li class="toclevel-1"><a href="#Related_data_structures"><span class="tocnumber">10</span> <span class="toctext">Related data structures</span></a></li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">11</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1"><a href="#External_links"><span class="tocnumber">12</span> <span class="toctext">External links</span></a></li>
</ul>
</td>
</tr>
</table>
<script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script>
<p><a name="History" id="History"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=1" title="Edit section: History">edit</a>]</span> <span class="mw-headline">History</span></h2>
<p>Linked lists were developed in 1955-56 by <a href="/wiki/Allen_Newell" title="Allen Newell">Allen Newell</a>, <a href="/wiki/Cliff_Shaw" title="Cliff Shaw">Cliff Shaw</a> and <a href="/wiki/Herbert_Simon" title="Herbert Simon">Herbert Simon</a> at <a href="/wiki/RAND" title="RAND">RAND Corporation</a> as the primary data structure for their <a href="/wiki/Information_Processing_Language" title="Information Processing Language">Information Processing Language</a>. IPL was used by the authors to develop several early <a href="/wiki/Artificial_intelligence" title="Artificial intelligence">artificial intelligence</a> programs, including the Logic Theory Machine, the <a href="/wiki/General_Problem_Solver" title="General Problem Solver">General Problem Solver</a>, and a computer chess program. Reports on their work appeared in <i>IRE Transactions on Information Theory</i> in 1956, and several conference proceedings from 1957-1959, including <i>Proceedings of the Western Joint Computer Conference</i> in 1957 and 1958, and <i>Information Processing</i> (Proceedings of the first <a href="/wiki/UNESCO" title="UNESCO">UNESCO</a> International Conference on Information Processing) in 1959. The now-classic diagram consisting of blocks representing list nodes with arrows pointing to successive list nodes appears in "Programming the Logic Theory Machine" by Newell and Shaw in <i>Proc. WJCC,</i> February 1957. Newell and Simon were recognized with the ACM <a href="/wiki/Turing_Award" title="Turing Award">Turing Award</a> in 1975 for having "made basic contributions to artificial intelligence, the psychology of human cognition, and list processing".</p>
<p>The problem of <a href="/wiki/Machine_translation" title="Machine translation">machine translation</a> for <a href="/wiki/Natural_language_processing" title="Natural language processing">natural language processing</a> led <a href="/wiki/Victor_Yngve" title="Victor Yngve">Victor Yngve</a> at <a href="/wiki/Massachusetts_Institute_of_Technology" title="Massachusetts Institute of Technology">Massachusetts Institute of Technology</a> (MIT) to use linked lists as data structures in his <a href="/wiki/COMIT" title="COMIT">COMIT</a> programming language for computer research in the field of <a href="/wiki/Linguistics" title="Linguistics">linguistics</a>. A report on this language entitled "A programming language for mechanical translation" appeared in <i>Mechanical Translation</i> in 1958.</p>
<p><a href="/wiki/Lisp_programming_language" title="Lisp programming language">LISP</a>, standing for <i>list processor</i>, was created by <a href="/wiki/John_McCarthy_%28computer_scientist%29" title="John McCarthy (computer scientist)">John McCarthy</a> in 1958 while he was at MIT and in 1960 he published its design in a paper in the <a href="/wiki/Communications_of_the_ACM" title="Communications of the ACM">Communications of the ACM</a>, entitled "Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I". One of LISP's major data structures is the linked list.</p>
<p>By the early 1960s, the utility of both linked lists and languages which use these structures as their primary data representation was well established. Bert Green of the <a href="/wiki/MIT" title="MIT">MIT</a> <a href="/wiki/Lincoln_Laboratory" title="Lincoln Laboratory">Lincoln Laboratory</a> published a review article entitled "Computer languages for symbol manipulation" in <i>IRE Transactions on Human Factors in Electronics</i> in March 1961 which summarized the advantages of the linked list approach. A later review article, "A Comparison of list-processing computer languages" by Bobrow and Raphael, appeared in <i>Communications of the ACM</i> in April 1964.</p>
<p>Several operating systems developed by Technical Systems Consultants (originally of West Lafayette Indiana, and later of Raleigh, North Carolina) used singly linked lists as file structures. A directory entry pointed to the first sector of a file, and succeeding portions of the file were located by traversing pointers. Systems using this technique included Flex (for the Motorola 6800 CPU), mini-Flex (same CPU), and Flex9 (for the Motorola 6809 CPU). A variant developed by TSC for and marketed by Smoke Signal Broadcasting in California, used doubly linked lists in the same manner.</p>
<p>The TSS operating system, developed by IBM for the System 360/370 machines, used a double linked list for their file system catalog. The directory structure was similar to Unix, where a directory could contain files and/or other directories and extend to any depth. A utility <i>flea</i> was created to fix file system problems after a crash, since modified portions of the file catalog were sometimes in memory when a crash occurred. Problems were detected by comparing the forward and backward links for consistency. If a forward link was corrupt, then if a backward link to the infected node was found, the forward link was set to the node with the backward link. A humorous comment in the source code where this utility was invoked stated "Everyone knows a flea caller gets rid of bugs in cats".</p>
<p><a name="Types_of_linked_lists" id="Types_of_linked_lists"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=2" title="Edit section: Types of linked lists">edit</a>]</span> <span class="mw-headline">Types of linked lists</span></h2>
<p><a name="Linearly-linked_list" id="Linearly-linked_list"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=3" title="Edit section: Linearly-linked list">edit</a>]</span> <span class="mw-headline">Linearly-linked list</span></h3>
<p><a name="Singly-linked_list" id="Singly-linked_list"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=4" title="Edit section: Singly-linked list">edit</a>]</span> <span class="mw-headline">Singly-linked list</span></h4>
<p>The simplest kind of linked list is a <b>singly-linked list</b> (or <b>slist</b> for short), which has one link per node. This link points to the next node in the list, or to a <a href="/wiki/Null_%28computer%29" title="Null (computer)">null</a> value or empty list if it is the final node.</p>
<center><a href="/wiki/Image:Singly-linked-list.svg" class="image" title="Image:Singly-linked-list.svg"><img alt="Image:Singly-linked-list.svg" src="http://upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Singly-linked-list.svg/408px-Singly-linked-list.svg.png" width="408" height="41" border="0" /></a><br />
<small><i>A singly-linked list containing three integer values</i></small></center>
<p><a name="Doubly-linked_list" id="Doubly-linked_list"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=5" title="Edit section: Doubly-linked list">edit</a>]</span> <span class="mw-headline">Doubly-linked list</span></h4>
<p>A more sophisticated kind of linked list is a <b>doubly-linked list</b> or <b>two-way linked list</b>. Each node has two links: one points to the previous node, or points to a <a href="/wiki/Null_%28computer%29" title="Null (computer)">null</a> value or empty list if it is the first node; and one points to the next, or points to a <a href="/wiki/Null_%28computer%29" title="Null (computer)">null</a> value or empty list if it is the final node.</p>
<center><a href="/wiki/Image:Doubly-linked-list.svg" class="image" title="Image:Doubly-linked-list.svg"><img alt="Image:Doubly-linked-list.svg" src="http://upload.wikimedia.org/wikipedia/commons/thumb/5/5e/Doubly-linked-list.svg/610px-Doubly-linked-list.svg.png" width="610" height="41" border="0" /></a><br />
<small><i>A doubly-linked list containing three integer values</i></small></center>
<p>In some very low level languages, <a href="/wiki/Xor_linked_list" title="Xor linked list">Xor-linking</a> offers a way to implement doubly-linked lists using a single word for both links, although the use of this technique is usually discouraged. A similar link storage preserving technique is the <a href="/wiki/Subtraction_edge" title="Subtraction edge">subtraction edge</a>.</p>
<p><a name="Circularly-linked_list" id="Circularly-linked_list"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=6" title="Edit section: Circularly-linked list">edit</a>]</span> <span class="mw-headline">Circularly-linked list</span></h3>
<p>In a <b>circularly-linked list</b>, the first and final nodes are linked together. This can be done for both singly and doubly linked lists. To traverse a circular linked list, you begin at any node and follow the list in either direction until you return to the original node. Viewed another way, circularly-linked lists can be seen as having no beginning or end. This type of list is most useful for managing buffers for data ingest, and in cases where you have one object in a list and wish to see all other objects in the list.</p>
<p>The pointer pointing to the whole list may be called the access pointer.</p>
<center><a href="/wiki/Image:Circularly-linked-list.svg" class="image" title="Image:Circularly-linked-list.svg"><img alt="Image:Circularly-linked-list.svg" src="http://upload.wikimedia.org/wikipedia/commons/thumb/d/df/Circularly-linked-list.svg/350px-Circularly-linked-list.svg.png" width="350" height="60" border="0" /></a><br />
<small><i>A circularly-linked list containing three integer values</i></small></center>
<p><a name="Singly-circularly-linked_list" id="Singly-circularly-linked_list"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=7" title="Edit section: Singly-circularly-linked list">edit</a>]</span> <span class="mw-headline">Singly-circularly-linked list</span></h4>
<p>In a <b>singly-circularly-linked list</b>, each node has one link, similar to an ordinary <i>singly-linked list</i>, except that the next link of the last node points back to the first node. As in a singly-linked list, new nodes can only be efficiently inserted after a node we already have a reference to. For this reason, it's usual to retain a reference to only the last element in a singly-circularly-linked list, as this allows quick insertion at the beginning, and also allows access to the first node through the last node's next pointer. <sup id="_ref-bruno99_0" class="reference"><a href="#_note-bruno99" title="">[2]</a></sup></p>
<p><a name="Doubly-circularly-linked_list" id="Doubly-circularly-linked_list"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=8" title="Edit section: Doubly-circularly-linked list">edit</a>]</span> <span class="mw-headline">Doubly-circularly-linked list</span></h4>
<p>In a <b>doubly-circularly-linked list</b>, each node has two links, similar to a <i>doubly-linked list</i>, except that the previous link of the first node points to the last node and the next link of the last node points to the first node. As in doubly-linked lists, insertions and removals can be done at any point with access to any nearby node. Although structurally a doubly-circularly-linked list has no beginning or end, an external access pointer may formally establish the pointed node to be the head node or the tail node, and maintain order just as well as a doubly-linked list with sentinel nodes. <sup id="_ref-bruno99_1" class="reference"><a href="#_note-bruno99" title="">[2]</a></sup></p>
<p><a name="Sentinel_nodes" id="Sentinel_nodes"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=9" title="Edit section: Sentinel nodes">edit</a>]</span> <span class="mw-headline">Sentinel nodes</span></h3>
<p>Linked lists sometimes have a special <i>dummy</i> or <i><a href="/wiki/Sentinel_node" title="Sentinel node">sentinel node</a></i> at the beginning and/or at the end of the list, which is not used to store data. Its purpose is to simplify or speed up some operations, by ensuring that every data node always has a previous and/or next node, and that every list (even one that contains no data elements) always has a "first" and "last" node. <a href="/wiki/Lisp_programming_language" title="Lisp programming language">Lisp</a> has such a design - the special value nil is used to mark the end of a 'proper' singly-linked list, or chain of <a href="/wiki/Cons" title="Cons">cons cells</a> as they are called. A list does not have to end in nil, but a list that did not would be termed 'improper'.</p>
<p><a name="Applications_of_linked_lists" id="Applications_of_linked_lists"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=10" title="Edit section: Applications of linked lists">edit</a>]</span> <span class="mw-headline">Applications of linked lists</span></h2>
<p>Linked lists are used as a building block for many other data structures, such as <a href="/wiki/Stack_%28data_structure%29" title="Stack (data structure)">stacks</a>, <a href="/wiki/Queue_%28data_structure%29" title="Queue (data structure)">queues</a> and their variations.</p>
<p>The "data" field of a node can be another linked list. By this device, one can construct many linked data structures with lists; this practice originated in the <a href="/wiki/Lisp_programming_language" title="Lisp programming language">Lisp programming language</a>, where linked lists are a primary (though by no means the only) data structure, and is now a common feature of the functional programming style.</p>
<p>Sometimes, linked lists are used to implement <a href="/wiki/Associative_array" title="Associative array">associative arrays</a>, and are in this context called <b>association lists</b>. There is very little good to be said about this use of linked lists; they are easily outperformed by other data structures such as <a href="/wiki/Self-balancing_binary_search_tree" title="Self-balancing binary search tree">self-balancing binary search trees</a> even on small data sets (see the discussion in <a href="/wiki/Associative_array" title="Associative array">associative array</a>). However, sometimes a linked list is dynamically created out of a subset of nodes in such a tree, and used to more efficiently traverse that set.</p>
<p><a name="Tradeoffs" id="Tradeoffs"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=11" title="Edit section: Tradeoffs">edit</a>]</span> <span class="mw-headline">Tradeoffs</span></h2>
<p>As with most choices in computer programming and design, no method is well suited to all circumstances. A linked list data structure might work well in one case, but cause problems in another. This is a list of some of the common tradeoffs involving linked list structures. In general, if you have a dynamic collection, where elements are frequently being added and deleted, and the location of new elements added to the list is significant, then benefits of a linked list increase.</p>
<p><a name="Linked_lists_vs._arrays" id="Linked_lists_vs._arrays"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=12" title="Edit section: Linked lists vs. arrays">edit</a>]</span> <span class="mw-headline">Linked lists vs. arrays</span></h3>
<table style="float: right" class="wikitable">
<tr>
<th></th>
<th>Array</th>
<th>Linked list</th>
</tr>
<tr>
<td>Indexing</td>
<td>O(1)</td>
<td>O(<i>n</i>)</td>
</tr>
<tr>
<td>Inserting / Deleting at end</td>
<td>O(1)</td>
<td>O(1) or O(<i>n</i>)<sup id="_ref-1" class="reference"><a href="#_note-1" title="">[3]</a></sup></td>
</tr>
<tr>
<td>Inserting / Deleting in middle (with iterator)</td>
<td>O(<i>n</i>)</td>
<td>O(1)</td>
</tr>
<tr>
<td><a href="/wiki/Persistent_data_structure" title="Persistent data structure">Persistent</a></td>
<td>No</td>
<td>Singly yes</td>
</tr>
<tr>
<td><a href="/wiki/Locality_of_reference" title="Locality of reference">Locality</a></td>
<td>Great</td>
<td>Bad</td>
</tr>
</table>
<p>Linked lists have several advantages over <a href="/wiki/Array" title="Array">arrays</a>. Elements can be inserted into linked lists indefinitely, while an array will eventually either fill up or need to be resized, an expensive operation that may not even be possible if memory is fragmented. Similarly, an array from which many elements are removed may become wastefully empty or need to be made smaller.</p>
<p>Further memory savings can be achieved, in certain cases, by sharing the same "tail" of elements among two or more lists — that is, the lists end in the same sequence of elements. In this way, one can add new elements to the front of the list while keeping a reference to both the new and the old versions — a simple example of a <a href="/wiki/Persistent_data_structure" title="Persistent data structure">persistent data structure</a>.</p>
<p>On the other hand, arrays allow <a href="/wiki/Random_access" title="Random access">random access</a>, while linked lists allow only <a href="/wiki/Sequential_access" title="Sequential access">sequential access</a> to elements. Singly-linked lists, in fact, can only be traversed in one direction. This makes linked lists unsuitable for applications where it's useful to look up an element by its index quickly, such as <a href="/wiki/Heapsort" title="Heapsort">heapsort</a>. Sequential access on arrays is also faster than on linked lists on many machines due to <a href="/wiki/Locality_of_reference" title="Locality of reference">locality of reference</a> and data caches. Linked lists receive almost no benefit from the cache.</p>
<p>Another disadvantage of linked lists is the extra storage needed for references, which often makes them impractical for lists of small data items such as <a href="/wiki/Character_%28computing%29" title="Character (computing)">characters</a> or <a href="/wiki/Boolean_value" title="Boolean value">boolean values</a>. It can also be slow, and with a naïve allocator, wasteful, to allocate memory separately for each new element, a problem generally solved using <a href="/wiki/Memory_pool" title="Memory pool">memory pools</a>.</p>
<p>A number of linked list variants exist that aim to ameliorate some of the above problems. <a href="/wiki/Unrolled_linked_list" title="Unrolled linked list">Unrolled linked lists</a> store several elements in each list node, increasing cache performance while decreasing memory overhead for references. <a href="/wiki/CDR_coding" title="CDR coding">CDR coding</a> does both these as well, by replacing references with the actual data referenced, which extends off the end of the referencing record.</p>
<p>A good example that highlights the pros and cons of using arrays vs. linked lists is by implementing a program that resolves the <a href="/wiki/Josephus_problem" title="Josephus problem">Josephus problem</a>. The Josephus problem is an election method that works by having a group of people stand in a circle. Starting at a predetermined person, you count around the circle <i>n</i> times. Once you reach <i>n</i>th person, take them out of the circle and have the members close the circle. Then count around the circle the same <i>n</i> times and repeat the process, until only one person is left. That person wins the election. This shows the strengths and weaknesses of a linked list vs. an array, because if you view the people as connected nodes in a circular linked list then it shows how easily the linked list is able to delete nodes (as it only has to rearrange the links to the different nodes). However, the linked list will be poor at finding the next person to remove and will need to recurse through the list until it finds that person. An array, on the other hand, will be poor at deleting nodes (or elements) as it cannot remove one node without individually shifting all the elements up the list by one.However, it is exceptionally easy to find the <i>n</i>th person in the circle by directly referencing them by their position in the array.</p>
<p><a name="Doubly-linked_vs._singly-linked" id="Doubly-linked_vs._singly-linked"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=13" title="Edit section: Doubly-linked vs. singly-linked">edit</a>]</span> <span class="mw-headline">Doubly-linked vs. singly-linked</span></h3>
<p>Double-linked lists require more space per node (unless one uses <a href="/wiki/Xor_linked_list" title="Xor linked list">xor-linking</a>), and their elementary operations are more expensive; but they are often easier to manipulate because they allow sequential access to the list in both directions. In particular, one can insert or delete a node in a constant number of operations given only that node's address. (Compared with singly-linked lists, which require the <i>previous</i> node's address in order to correctly insert or delete.) Some algorithms require access in both directions. On the other hand, they do not allow tail-sharing, and cannot be used as persistent data structures.</p>
<p><a name="Circularly-linked_vs._linearly-linked" id="Circularly-linked_vs._linearly-linked"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=14" title="Edit section: Circularly-linked vs. linearly-linked">edit</a>]</span> <span class="mw-headline">Circularly-linked vs. linearly-linked</span></h3>
<p>Circular linked lists are most useful for describing naturally circular structures, and have the advantage of regular structure and being able to traverse the list starting at any point. They also allow quick access to the first and last records through a single pointer (the address of the last element). Their main disadvantage is the complexity of iteration, which has subtle special cases.</p>
<p><a name="Sentinel_nodes_2" id="Sentinel_nodes_2"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=15" title="Edit section: Sentinel nodes">edit</a>]</span> <span class="mw-headline">Sentinel nodes</span></h3>
<p>Sentinel nodes may simplify certain list operations, by ensuring that the next and/or previous nodes exist for every element. However sentinel nodes use up extra space (especially in applications that use many short lists), and they may complicate other operations. To avoid the extra space requirement the sentinel nodes can often be reused as references to the first and/or last node of the list.</p>
<p><a name="Linked_list_operations" id="Linked_list_operations"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=16" title="Edit section: Linked list operations">edit</a>]</span> <span class="mw-headline">Linked list operations</span></h2>
<p>When manipulating linked lists in-place, care must be taken to not use values that you have invalidated in previous assignments. This makes algorithms for inserting or deleting linked list nodes somewhat subtle. This section gives <a href="/wiki/Pseudocode" title="Pseudocode">pseudocode</a> for adding or removing nodes from singly, doubly, and circularly linked lists in-place. Throughout we will use <i>null</i> to refer to an end-of-list marker or <a href="/wiki/Sentinel_value" title="Sentinel value">sentinel</a>, which may be implemented in a number of ways.</p>
<p><a name="Linearly-linked_lists" id="Linearly-linked_lists"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=17" title="Edit section: Linearly-linked lists">edit</a>]</span> <span class="mw-headline">Linearly-linked lists</span></h3>
<p><a name="Singly-linked_lists" id="Singly-linked_lists"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=18" title="Edit section: Singly-linked lists">edit</a>]</span> <span class="mw-headline">Singly-linked lists</span></h4>
<p>Our node data structure will have two fields. We also keep a variable <i>firstNode</i> which always points to the first node in the list, or is <i>null</i> for an empty list.</p>
<pre>
 <b>record</b> <i>Node</i> {
    data <i>// The data being stored in the node</i>
    next <i>// A <a href="/wiki/Reference" title="Reference">reference</a> to the next node, null for last node</i>
 }
</pre>
<pre>
 <b>record</b> <i>List</i> {
     <i>Node</i> firstNode   <i>// points to first node of list; null for empty list</i>
 }
</pre>
<p>Traversal of a singly-linked list is simple, beginning at the first node and following each <i>next</i> link until we come to the end:</p>
<pre>
 node := list.firstNode
 <b>while</b> node not null {
     <i>(do something with node.data)</i>
     node := node.next
 }
</pre>
<p>The following code inserts a node after an existing node in a singly linked list. The diagram shows how it works. Inserting a node before an existing one cannot be done; instead, you have to locate it while keeping track of the previous node.</p>
<div class="center">
<div class="floatnone"><span><a href="/wiki/Image:Singly_linked_list_insert_after.png" class="image" title="Singly linked list insert after.png"><img alt="" src="http://upload.wikimedia.org/wikipedia/en/0/00/Singly_linked_list_insert_after.png" width="400" height="115" border="0" /></a></span></div>
</div>
<pre>
 <b>function</b> insertAfter(<i>Node</i> node, <i>Node</i> newNode) { <i>// insert newNode after node</i>
     newNode.next := node.next
     node.next    := newNode
 }
</pre>
<p>Inserting at the beginning of the list requires a separate function. This requires updating <i>firstNode</i>.</p>
<pre>
 <b>function</b> insertBeginning(<i>List</i> list, <i>Node</i> newNode) { <i>// insert node before current first node</i>
     newNode.next   := list.firstNode
     list.firstNode := newNode
 }
</pre>
<p>Similarly, we have functions for removing the node <i>after</i> a given node, and for removing a node from the beginning of the list. The diagram demonstrates the former. To find and remove a particular node, one must again keep track of the previous element.</p>
<div class="center">
<div class="floatnone"><span><a href="/wiki/Image:Singly_linked_list_delete_after.png" class="image" title="Singly linked list delete after.png"><img alt="" src="http://upload.wikimedia.org/wikipedia/en/e/ec/Singly_linked_list_delete_after.png" width="263" height="130" border="0" /></a></span></div>
</div>
<pre>
 <b>function</b> removeAfter(<i>Node</i> node) { <i>// remove node past this one</i>
     obsoleteNode := node.next
     node.next := node.next.next
     destroy obsoleteNode
 }
</pre>
<pre>
 <b>function</b> removeBeginning(<i>List</i> list) { <i>// remove first node</i>
     obsoleteNode := list.firstNode
     list.firstNode := list.firstNode.next          <i>// point past deleted node</i>
     destroy obsoleteNode
 }
</pre>
<p>Notice that removeBeginning() sets <i>list.firstNode</i> to <i>null</i> when removing the last node in the list.</p>
<p>Since we can't iterate backwards, efficient "insertBefore" or "removeBefore" operations are not possible.</p>
<p>Appending one linked list to another can be inefficient unless a reference to the tail is kept as part of the List structure, because we must traverse the entire first list in order to find the tail, and then append the second list to this. Thus, if two linearly-linked lists are each of length <span class="texhtml"><i>n</i></span>, list appending has <a href="/w/index.php?title=Asymptotic_time_complexity&amp;action=edit" class="new" title="Asymptotic time complexity">asymptotic time complexity</a> of <span class="texhtml"><i>O</i>(<i>n</i>)</span>. In the Lisp family of languages, list appending is provided by the <code><a href="/wiki/Append" title="Append">append</a></code> procedure.</p>
<p>Many of the special cases of linked list operations can be eliminated by including a dummy element at the front of the list. This ensures that there are no special cases for the beginning of the list and renders both insertBeginning() and removeBeginning() unnecessary. In this case, the first useful data in the list will be found at list.firstNode.next.</p>
<p><a name="Doubly-linked_lists" id="Doubly-linked_lists"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=19" title="Edit section: Doubly-linked lists">edit</a>]</span> <span class="mw-headline">Doubly-linked lists</span></h4>
<p>With doubly-linked lists there are even more pointers to update, but also less information is needed, since we can use backwards pointers to observe preceding elements in the list. This enables new operations, and eliminates special-case functions. We will add a <i>prev</i> field to our nodes, pointing to the previous element, and a <i>lastNode</i> field to our list structure which always points to the last node in the list. Both <i>list.firstNode</i> and <i>list.lastNode</i> are <i>null</i> for an empty list.</p>
<pre>
 <b>record</b> <i>Node</i> {
    data <i>// The data being stored in the node</i>
    next <i>// A <a href="/wiki/Reference" title="Reference">reference</a> to the next node; null for last node</i>
    prev <i>// A reference to the previous node; null for first node</i>
 }
</pre>
<pre>
 <b>record</b> <i>List</i> {
     <i>Node</i> firstNode   <i>// points to first node of list; null for empty list</i>
     <i>Node</i> lastNode    <i>// points to last node of list; null for empty list</i>
 }
</pre>
<p>Iterating through a doubly linked list can be done in either direction. In fact, direction can change many times, if desired.</p>
<p><i>Forwards</i></p>
<pre>
 node := list.firstNode
 <b>while</b> node ≠ <b>null</b>
     &lt;do something with node.data&gt;
     node := node.next
</pre>
<p><i>Backwards</i></p>
<pre>
 node := list.lastNode
 <b>while</b> node ≠ <b>null</b>
     &lt;do something with node.data&gt;
     node := node.prev
</pre>
<p>These symmetric functions add a node either after or before a given node, with the diagram demonstrating after:</p>
<div class="center">
<div class="floatnone"><span><a href="/wiki/Image:Doubly_linked_list_insert_after.png" class="image" title="Doubly linked list insert after.png"><img alt="" src="http://upload.wikimedia.org/wikipedia/en/0/07/Doubly_linked_list_insert_after.png" width="495" height="114" border="0" /></a></span></div>
</div>
<pre>
 <b>function</b> insertAfter(<i>List</i> list, <i>Node</i> node, <i>Node</i> newNode)
     newNode.prev := node
     newNode.next := node.next
     <b>if</b> node.next = <b>null</b>
         list.lastNode := newNode
     <b>else</b>
         node.next.prev := newNode
     node.next := newNode
</pre>
<pre>
 <b>function</b> insertBefore(<i>List</i> list, <i>Node</i> node, <i>Node</i> newNode)
     newNode.prev := node.prev
     newNode.next := node
     <b>if</b> node.prev is null
         list.firstNode := newNode
     <b>else</b>
         node.prev.next := newNode
     node.prev    := newNode
</pre>
<p>We also need a function to insert a node at the beginning of a possibly-empty list:</p>
<pre>
 <b>function</b> insertBeginning(<i>List</i> list, <i>Node</i> newNode)
     <b>if</b> list.firstNode = <b>null</b>
         list.firstNode := newNode
         list.lastNode  := newNode
         newNode.prev := null
         newNode.next := null
     <b>else</b>
         insertBefore(list, list.firstNode, newNode)
</pre>
<p>A symmetric function inserts at the end:</p>
<pre>
 <b>function</b> insertEnd(<i>List</i> list, <i>Node</i> newNode)
     <b>if</b> list.lastNode = <b>null</b>
         insertBeginning(list, newNode)
     <b>else</b>
         insertAfter(list, list.lastNode, newNode)
</pre>
<p>Removing a node is easier, only requiring care with the <i>firstNode</i> and <i>lastNode</i>:</p>
<pre>
 <b>function</b> remove(<i>List</i> list, <i>Node</i> node)
   <b>if</b> node.prev = <b>null</b>
       list.firstNode := node.next
   <b>else</b>
       node.prev.next := node.next
   <b>if</b> node.next = <b>null</b>
       list.lastNode := node.prev
   <b>else</b>
       node.next.prev := node.prev
   destroy node
</pre>
<p>One subtle consequence of this procedure is that deleting the last element of a list sets both <i>firstNode</i> and <i>lastNode</i> to <i>null</i>, and so it handles removing the last node from a one-element list correctly. Notice that we also don't need separate "removeBefore" or "removeAfter" methods, because in a doubly-linked list we can just use "remove(node.prev)" or "remove(node.next)" where these are valid.</p>
<p><a name="Circularly-linked_lists" id="Circularly-linked_lists"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=20" title="Edit section: Circularly-linked lists">edit</a>]</span> <span class="mw-headline">Circularly-linked lists</span></h3>
<p>Circularly-linked lists can be either singly or doubly linked. In a circularly linked list, all nodes are linked in a continuous circle, without using <i>null.</i> For lists with a front and a back (such as a queue), one stores a reference to the last node in the list. The <i>next</i> node after the last node is the first node. Elements can be added to the back of the list and removed from the front in constant time.</p>
<p>Both types of circularly-linked lists benefit from the ability to traverse the full list beginning at any given node. This often allows us to avoid storing <i>firstNode</i> and <i>lastNode</i>, although if the list may be empty we need a special representation for the empty list, such as a <i>lastNode</i> variable which points to some node in the list or is <i>null</i> if it's empty; we use such a <i>lastNode</i> here. This representation significantly simplifies adding and removing nodes with a non-empty list, but empty lists are then a special case.</p>
<p><a name="Doubly-circularly-linked_lists" id="Doubly-circularly-linked_lists"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=21" title="Edit section: Doubly-circularly-linked lists">edit</a>]</span> <span class="mw-headline">Doubly-circularly-linked lists</span></h4>
<p>Assuming that <i>someNode</i> is some node in a non-empty list, this code iterates through that list starting with <i>someNode</i> (any node will do):</p>
<p><i>Forwards</i></p>
<pre>
 node := someNode
 <b>do</b>
     do something with node.value
     node := node.next
 <b>while</b> node ≠ someNode
</pre>
<p><i>Backwards</i></p>
<pre>
 node := someNode
 <b>do</b>
     do something with node.value
     node := node.prev
 <b>while</b> node ≠ someNode
</pre>
<p>Notice the postponing of the test to the end of the loop. This is important for the case where the list contains only the single node <i>someNode</i>.</p>
<p>This simple function inserts a node into a doubly-linked circularly-linked list after a given element:</p>
<pre>
 <b>function</b> insertAfter(<i>Node</i> node, <i>Node</i> newNode)
     newNode.next := node.next
     newNode.prev := node
     node.next.prev := newNode
     node.next      := newNode
</pre>
<p>To do an "insertBefore", we can simply "insertAfter(node.prev, newNode)". Inserting an element in a possibly empty list requires a special function:</p>
<pre>
 <b>function</b> insertEnd(<i>List</i> list, <i>Node</i> node)
     <b>if</b> list.lastNode = <b>null</b>
         node.prev := node
         node.next := node
     <b>else</b>
         insertAfter(list.lastNode, node)
     list.lastNode := node
</pre>
<p>To insert at the beginning we simply "insertAfter(list.lastNode, node)". Finally, removing a node must deal with the case where the list empties:</p>
<pre>
 <b>function</b> remove(<i>List</i> list, <i>Node</i> node)
     <b>if</b> node.next = node
         list.lastNode := <b>null</b>
     <b>else</b>
         node.next.prev := node.prev
         node.prev.next := node.next
         <b>if</b> node = list.lastNode
             list.lastNode := node.prev;
     destroy node
</pre>
<p>As in doubly-linked lists, "removeAfter" and "removeBefore" can be implemented with "remove(list, node.prev)" and "remove(list, node.next)".</p>
<p><a name="Linked_lists_using_arrays_of_nodes" id="Linked_lists_using_arrays_of_nodes"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=22" title="Edit section: Linked lists using arrays of nodes">edit</a>]</span> <span class="mw-headline">Linked lists using arrays of nodes</span></h2>
<p>Languages that do not support any type of <a href="/wiki/Reference_%28computer_science%29" title="Reference (computer science)">reference</a> can still create links by replacing pointers with array indices. The approach is to keep an <a href="/wiki/Array" title="Array">array</a> of <a href="/wiki/Record_%28computer_science%29" title="Record (computer science)">records</a>, where each record has integer fields indicating the index of the next (and possibly previous) node in the array. Not all nodes in the array need be used. If records are not supported as well, <a href="/wiki/Parallel_array" title="Parallel array">parallel arrays</a> can often be used instead.</p>
<p>As an example, consider the following linked list record that uses arrays instead of pointers:</p>
<pre>
 <b>record</b> <i>Entry</i> {
    <i>integer</i> next; <i>// index of next entry in array</i>
    <i>integer</i> prev; <i>// previous entry (if double-linked)</i>
    <i>string</i> name;
    <i>real</i> balance;
 }
</pre>
<p>By creating an array of these structures, and an integer variable to store the index of the first element, a linked list can be built:</p>
<pre>
<i>integer</i> listHead;
<i>Entry</i> Records[1000];
</pre>
<p>Links between elements are formed by placing the array index of the next (or previous) cell into the Next or Prev field within a given element. For example:</p>
<table border="1" cellspacing="0" cellpadding="3">
<tr>
<th>Index</th>
<th>Next</th>
<th>Prev</th>
<th>Name</th>
<th>Balance</th>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>4</td>
<td>Jones, John</td>
<td>123.45</td>
</tr>
<tr>
<td>1</td>
<td>-1</td>
<td>0</td>
<td>Smith, Joseph</td>
<td>234.56</td>
</tr>
<tr>
<td>2 (listHead)</td>
<td>4</td>
<td>-1</td>
<td>Adams, Adam</td>
<td>0.00</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td>Ignore, Ignatius</td>
<td>999.99</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>2</td>
<td>Another, Anita</td>
<td>876.54</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
<p>In the above example, <code>ListHead</code> would be set to 2, the location of the first entry in the list. Notice that entry 3 and 5 through 7 are not part of the list. These cells are available for any additions to the list. By creating a <code>ListFree</code> integer variable, a <a href="/wiki/Free_list" title="Free list">free list</a> could be created to keep track of what cells are available. If all entries are in use, the size of the array would have to be increased or some elements would have to be deleted before new entries could be stored in the list.</p>
<p>The following code would traverse the list and display names and account balance:</p>
<pre>
i := listHead;
<b>while</b> i &gt;= 0 { '// loop through the list
     print i, Records[i].name, Records[i].balance <i>// print entry</i>
     i = Records[i].next;
}
</pre>
<p>When faced with a choice, the advantages of this approach include:</p>
<ul>
<li>The linked list is relocatable, meaning it can be moved about in memory at will, and it can also be quickly and directly <a href="/wiki/Serialization" title="Serialization">serialized</a> for storage on disk or transfer over a network.</li>
<li>Especially for a small list, array indexes can occupy significantly less space than a full pointer on many architectures.</li>
<li><a href="/wiki/Locality_of_reference" title="Locality of reference">Locality of reference</a> can be improved by keeping the nodes together in memory and by periodically rearranging them, although this can also be done in a general store.</li>
<li>Naïve <a href="/wiki/Dynamic_memory_allocation" title="Dynamic memory allocation">dynamic memory allocators</a> can produce an excessive amount of overhead storage for each node allocated; almost no allocation overhead is incurred per node in this approach.</li>
<li>Seizing an entry from a pre-allocated array is faster than using dynamic memory allocation for each node, since dynamic memory allocation typically requires a search for a free memory block of the desired size.</li>
</ul>
<p>This approach has one main disadvantage, however: it creates and manages a private memory space for its nodes. This leads to the following issues:</p>
<ul>
<li>It increase complexity of the implementation.</li>
<li>Growing a large array when it is full may be difficult or impossible, whereas finding space for a new linked list node in a large, general memory pool may be easier.</li>
<li>Adding elements to a dynamic array will occasionally (when it is full) unexpectedly take linear (<a href="/wiki/Big-O_notation" title="Big-O notation">O</a>(n)) instead of constant time (although it's still an <a href="/wiki/Amortized_analysis" title="Amortized analysis">amortized</a> constant).</li>
<li>Using a general memory pool leaves more memory for other data if the list is smaller than expected or if many nodes are freed.</li>
</ul>
<p>For these reasons, this approach is mainly used for languages that do not support dynamic memory allocation. These disadvantages are also mitigated if the maximum size of the list is known at the time the array is created.</p>
<p><a name="Language_support" id="Language_support"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=23" title="Edit section: Language support">edit</a>]</span> <span class="mw-headline">Language support</span></h2>
<p>Many <a href="/wiki/Programming_language" title="Programming language">programming languages</a> such as <a href="/wiki/Lisp_programming_language" title="Lisp programming language">Lisp</a> and <a href="/wiki/Scheme_%28programming_language%29" title="Scheme (programming language)">Scheme</a> have singly linked lists built in. In many <a href="/wiki/Functional_programming_language" title="Functional programming language">functional languages</a>, these lists are constructed from nodes, each called a <i><a href="/wiki/Cons" title="Cons">cons</a></i> or <i>cons cell</i>. The cons has two fields: the <i><a href="/wiki/Car_and_cdr" title="Car and cdr">car</a></i>, a reference to the data for that node, and the <i><a href="/wiki/Car_and_cdr" title="Car and cdr">cdr</a></i>, a reference to the next node. Although cons cells can be used to build other data structures, this is their primary purpose.</p>
<p>In languages that support <a href="/wiki/Abstract_data_type" title="Abstract data type">Abstract data types</a> or templates, linked list ADTs or templates are available for building linked lists. In other languages, linked lists are typically built using <a href="/wiki/Reference" title="Reference">references</a> together with <a href="/wiki/Record_%28computer_science%29" title="Record (computer science)">records</a>. Here is a complete example in <a href="/wiki/C_%28programming_language%29" title="C (programming language)">C</a>:</p>
<div dir="ltr">
<pre class="source-C">
<span class="co2">#include &lt;stdio.h&gt;   /* for printf */</span>
<span class="co2">#include &lt;stdlib.h&gt;  /* for malloc */</span>
 
<span class="kw4">typedef</span> <span class="kw4">struct</span> ns <span class="br0">{</span>
        <span class="kw4">int</span> data;
        <span class="kw4">struct</span> ns *next;
<span class="br0">}</span> node;
 
node *list_add<span class="br0">(</span>node **p, <span class="kw4">int</span> i<span class="br0">)</span> <span class="br0">{</span>
    node *n = malloc<span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span>node<span class="br0">)</span><span class="br0">)</span>; <span class="coMULTI">/* you normally don't cast a return value for malloc */</span>
    n-&gt;next = *p;
    *p = n;
    n-&gt;data = i;
    <span class="kw1">return</span> n;
<span class="br0">}</span>
 
<span class="kw4">void</span> list_remove<span class="br0">(</span>node **p<span class="br0">)</span> <span class="br0">{</span> <span class="coMULTI">/* remove head */</span>
    <span class="kw1">if</span> <span class="br0">(</span>*p != <span class="kw2">NULL</span><span class="br0">)</span> <span class="br0">{</span>
        node *n = *p;
        *p = <span class="br0">(</span>*p<span class="br0">)</span>-&gt;next;
        free<span class="br0">(</span>n<span class="br0">)</span>;
    <span class="br0">}</span>
<span class="br0">}</span>
 
node **list_search<span class="br0">(</span>node **n, <span class="kw4">int</span> i<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">while</span> <span class="br0">(</span>*n != <span class="kw2">NULL</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw1">if</span> <span class="br0">(</span><span class="br0">(</span>*n<span class="br0">)</span>-&gt;data == i<span class="br0">)</span> <span class="br0">{</span>
            <span class="kw1">return</span> n;
        <span class="br0">}</span>
        n = &amp;<span class="br0">(</span>*n<span class="br0">)</span>-&gt;next;
    <span class="br0">}</span>
    <span class="kw1">return</span> <span class="kw2">NULL</span>;
<span class="br0">}</span>
 
<span class="kw4">void</span> list_print<span class="br0">(</span>node *n<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">if</span> <span class="br0">(</span>n == <span class="kw2">NULL</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"list is empty<span class="es0">\n</span>"</span><span class="br0">)</span>;
    <span class="br0">}</span>
    <span class="kw1">while</span> <span class="br0">(</span>n != <span class="kw2">NULL</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"print %p %p %d<span class="es0">\n</span>"</span>, n, n-&gt;next, n-&gt;data<span class="br0">)</span>;
        n = n-&gt;next;
    <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span> <span class="br0">{</span>
    node *n = <span class="kw2">NULL</span>;
 
    list_add<span class="br0">(</span>&amp;n, <span class="nu0">0</span><span class="br0">)</span>; <span class="coMULTI">/* list: 0 */</span>
    list_add<span class="br0">(</span>&amp;n, <span class="nu0">1</span><span class="br0">)</span>; <span class="coMULTI">/* list: 1 0 */</span>
    list_add<span class="br0">(</span>&amp;n, <span class="nu0">2</span><span class="br0">)</span>; <span class="coMULTI">/* list: 2 1 0 */</span>
    list_add<span class="br0">(</span>&amp;n, <span class="nu0">3</span><span class="br0">)</span>; <span class="coMULTI">/* list: 3 2 1 0 */</span>
    list_add<span class="br0">(</span>&amp;n, <span class="nu0">4</span><span class="br0">)</span>; <span class="coMULTI">/* list: 4 3 2 1 0 */</span>
    list_print<span class="br0">(</span>n<span class="br0">)</span>;
    list_remove<span class="br0">(</span>&amp;n<span class="br0">)</span>;            <span class="coMULTI">/* remove first (4) */</span>
    list_remove<span class="br0">(</span>&amp;n-&gt;next<span class="br0">)</span>;      <span class="coMULTI">/* remove new second (2) */</span>
    list_remove<span class="br0">(</span>list_search<span class="br0">(</span>&amp;n, <span class="nu0">1</span><span class="br0">)</span><span class="br0">)</span>; <span class="coMULTI">/* remove cell containing 1 (first) */</span>
    list_remove<span class="br0">(</span>&amp;n-&gt;next<span class="br0">)</span>;      <span class="coMULTI">/* remove second to last node (0) */</span>
    list_remove<span class="br0">(</span>&amp;n<span class="br0">)</span>;            <span class="coMULTI">/* remove last (3) */</span>
    list_print<span class="br0">(</span>n<span class="br0">)</span>;
 
    <span class="kw1">return</span> <span class="nu0">0</span>;
<span class="br0">}</span>
</pre></div>
<p><a name="Internal_and_external_storage" id="Internal_and_external_storage"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=24" title="Edit section: Internal and external storage">edit</a>]</span> <span class="mw-headline">Internal and external storage</span></h2>
<p>When constructing a linked list, one is faced with the choice of whether to store the data of the list directly in the linked list nodes, called <i>internal storage</i>, or merely to store a reference to the data, called <i>external storage</i>. Internal storage has the advantage of making access to the data more efficient, requiring less storage overall, having better <a href="/wiki/Locality_of_reference" title="Locality of reference">locality of reference</a>, and simplifying memory management for the list (its data is allocated and deallocated at the same time as the list nodes).</p>
<p>External storage, on the other hand, has the advantage of being more generic, in that the same data structure and machine code can be used for a linked list no matter what the size of the data is. It also makes it easy to place the same data in multiple linked lists. Although with internal storage the same data can be placed in multiple lists by including multiple <i>next</i> references in the node data structure, it would then be necessary to create separate routines to add or delete cells based on each field. It is possible to create additional linked lists of elements that use internal storage by using external storage, and having the cells of the additional linked lists store references to the nodes of the linked list containing the data.</p>
<p>In general, if a set of data structures needs to be included in multiple linked lists, external storage is the best approach. If a set of data structures need to be included in only one linked list, then internal storage is slightly better, unless a generic linked list package using external storage is available. Likewise, if different sets of data that can be stored in the same data structure are to be included in a single linked list, then internal storage would be fine.</p>
<p>Another approach that can be used with some languages involves having different data structures, but all have the initial fields, including the <i>next</i> (and <i>prev</i> if double linked list) references in the same location. After defining separate structures for each type of data, a generic structure can be defined that contains the minimum amount of data shared by all the other structures and contained at the top (beginning) of the structures. Then generic routines can be created that use the minimal structure to perform linked list type operations, but separate routines can then handle the specific data. This approach is often used in message parsing routines, where several types of messages are received, but all start with the same set of fields, usually including a field for message type. The generic routines are used to add new messages to a queue when they are received, and remove them from the queue in order to process the message. The message type field is then used to call the correct routine to process the specific type of message.</p>
<p><a name="Example_of_internal_and_external_storage" id="Example_of_internal_and_external_storage"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=25" title="Edit section: Example of internal and external storage">edit</a>]</span> <span class="mw-headline">Example of internal and external storage</span></h3>
<p>Suppose you wanted to create a linked list of families and their members. Using internal storage, the structure might look like the following:</p>
<pre>
 <b>record</b> <i>member</i> { <i>// member of a family</i>
     <i>member</i> next
     <i>string</i> firstName
     <i>integer</i> age
 }
 <b>record</b> <i>family</i> { <i>// the family itself</i>
     <i>family</i> next
     <i>string</i> lastName
     <i>string</i> address
     <i>member</i> members <i>// head of list of members of this family</i>
 }
</pre>
<p>To print a complete list of families and their members using internal storage, we could write:</p>
<pre>
 aFamily := Families <i>// start at head of families list</i>
 <b>while</b> aFamily ≠ <b>null</b> { <i>// loop through list of families</i>
     print information about family
     aMember := aFamily.members <i>// get head of list of this family's members</i>
     <b>while</b> aMember ≠ <b>null</b> { <i>// loop through list of members</i>
         print information about member
         aMember := aMember.next
     }
     aFamily := aFamily.next
 }
</pre>
<p>Using external storage, we would create the following structures:</p>
<pre>
 <b>record</b> <i>node</i> { <i>// generic link structure</i>
     <i>node</i> next
     <i>pointer</i> data <i>// generic pointer for data at node</i>
 }
 <b>record</b> <i>member</i> { <i>// structure for family member</i>
     <i>string</i> firstName
     <i>integer</i> age
 }
 <b>record</b> <i>family</i> { <i>// structure for family</i>
     <i>string</i> lastName
     <i>string</i> address
     <i>node</i> members <i>// head of list of members of this family</i>
 }
</pre>
<p>To print a complete list of families and their members using external storage, we could write:</p>
<pre>
 famNode := Families <i>// start at head of families list</i>
 <b>while</b> famNode ≠ <b>null</b> { <i>// loop through list of families</i>
     aFamily = (family)famNode.data <i>// extract family from node</i>
     print information about family
     memNode := aFamily.members <i>// get list of family members</i>
     <b>while</b> memNode ≠ <b>null</b> { <i>// loop through list of members</i>
         aMember := (member)memNode.data <i>// extract member from node</i>
         print information about member
         memNode := memNode.next
     }
     famNode := famNode.next
 }
</pre>
<p>Notice that when using external storage, an extra step is needed to extract the record from the node and cast it into the proper data type. This is because both the list of families and the list of members within the family are stored in two linked lists using the same data structure (<i>node</i>), and this language does not have parametric types.</p>
<p>As long as the number of families that a member can belong to is known at compile time, internal storage works fine. If, however, a member needed to be included in an arbitrary number of families, with the specific number known only at run time, external storage would be necessary.</p>
<p><a name="Speeding_up_search" id="Speeding_up_search"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=26" title="Edit section: Speeding up search">edit</a>]</span> <span class="mw-headline">Speeding up search</span></h2>
<p>Finding a specific element in a linked list, even if it is sorted, normally requires O(<i>n</i>) time (<a href="/wiki/Linear_search" title="Linear search">linear search</a>). This is one of the primary disadvantages of linked lists over other data structures. In addition to some of the variants discussed in the above section, there are number of simple ways of improving search time.</p>
<p>In an unordered list, one simple heuristic for decreasing average search time is the <i>move-to-front heuristic</i>, which simply moves an element to the beginning of the list once it is found. This scheme, handy for creating simple caches, ensures that the most recently used items are also the quickest to find again.</p>
<p>Another common approach is to "<a href="/wiki/Index_%28database%29" title="Index (database)">index</a>" a linked list using a more efficient external data structure. For example, one can build a <a href="/wiki/Red-black_tree" title="Red-black tree">red-black tree</a> or <a href="/wiki/Hash_table" title="Hash table">hash table</a> whose elements are references to the linked list nodes. Multiple such indexes can be built on a single list. The disadvantage is that these indexes may need to be updated each time a node is added or removed (or at least, before that index is used again).</p>
<p><a name="Related_data_structures" id="Related_data_structures"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=27" title="Edit section: Related data structures">edit</a>]</span> <span class="mw-headline">Related data structures</span></h2>
<p>Both <a href="/wiki/Stack_%28data_structure%29" title="Stack (data structure)">stacks</a> and <a href="/wiki/Queue_%28data_structure%29" title="Queue (data structure)">queues</a> are often implemented using linked lists, and simply restrict the type of operations which are supported.</p>
<p>The <a href="/wiki/Skip_list" title="Skip list">skip list</a> is a linked list augmented with layers of pointers for quickly jumping over large numbers of elements, and then descending to the next layer. This process continues down to the bottom layer, which is the actual list.</p>
<p>A <a href="/wiki/Binary_tree" title="Binary tree">binary tree</a> can be seen as a type of linked list where the elements are themselves linked lists of the same nature. The result is that each node may include a reference to the first node of one or two other linked lists, which, together with their contents, form the subtrees below that node.</p>
<p>An <a href="/wiki/Unrolled_linked_list" title="Unrolled linked list">unrolled linked list</a> is a linked list in which each node contains an array of data values. This leads to improved cache performance, since more list elements are contiguous in memory, and reduced memory overhead, because less metadata needs to be stored for each element of the list.</p>
<p>A <a href="/wiki/Hash_table" title="Hash table">hash table</a> may use linked lists to store the chains of items that hash to the same position in the hash table.</p>
<p><a name="References" id="References"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=28" title="Edit section: References">edit</a>]</span> <span class="mw-headline">References</span></h2>
<div class="references-small">
<ol class="references">
<li id="_note-0"><b><a href="#_ref-0" title="">^</a></b> The actual insertion and deletion of nodes can be done in constant time, however searching for a particular node takes linear time.</li>
<li id="_note-bruno99">^ <a href="#_ref-bruno99_0" title=""><sup><i><b>a</b></i></sup></a> <a href="#_ref-bruno99_1" title=""><sup><i><b>b</b></i></sup></a> <cite id="CITEREFPreiss1999">Preiss, Bruno R. (1999), <i><a href="http://www.brpreiss.com/books/opus5/html/page97.html" class="external text" title="http://www.brpreiss.com/books/opus5/html/page97.html" rel="nofollow">Data Structures and Algorithms with Object-Oriented Design Patterns in Java</a></i>, Wiley, pp. page 97, 165, <a href="/w/index.php?title=Special:Booksources&amp;isbn=0471346136" class="internal">ISBN 0471-34613-6</a><span class="printonly">, &lt;<a href="http://www.brpreiss.com/books/opus5/html/page97.html" class="external free" title="http://www.brpreiss.com/books/opus5/html/page97.html" rel="nofollow">http://www.brpreiss.com/books/opus5/html/page97.html</a>&gt;</span></cite></li>
<li id="_note-1"><b><a href="#_ref-1" title="">^</a></b> If maintaining a link to the tail of the list, time is O(1); if the entire link must be searched to locate the tail link, O(n)</li>
</ol>
</div>
<ul>
<li><a href="/wiki/National_Institute_of_Standards_and_Technology" title="National Institute of Standards and Technology">National Institute of Standards and Technology</a> (<a href="/wiki/August_16" title="August 16">August 16</a>, <a href="/wiki/2004" title="2004">2004</a>). <a href="http://nist.gov/dads/HTML/linkedList.html" class="external text" title="http://nist.gov/dads/HTML/linkedList.html" rel="nofollow">Definition of a linked list</a>. Retrieved <a href="/wiki/December_14" title="December 14">December 14</a>, <a href="/wiki/2004" title="2004">2004</a>.</li>
<li>Antonakos, James L. and Mansfield, Kenneth C., Jr. <i>Practical Data Structures Using C/C++</i> (1999). Prentice-Hall. <a href="/w/index.php?title=Special:Booksources&amp;isbn=0132808439" class="internal">ISBN 0-13-280843-9</a>, pp. 165–190</li>
<li>Collins, William J. <i>Data Structures and the Java Collections Framework</i> (2002,2005) New York, NY: McGraw Hill. <a href="/w/index.php?title=Special:Booksources&amp;isbn=0072823798" class="internal">ISBN 0-07-282379-8</a>, pp. 239–303</li>
<li>Cormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford <i>Introductions to Algorithms</i> (2003). MIT Press. <a href="/w/index.php?title=Special:Booksources&amp;isbn=0262032937" class="internal">ISBN 0-262-03293-7</a>, pp. 205–213, 501–505</li>
<li>Green, Bert F. Jr. (1961). Computer Languages for Symbol Manipulation. <i>IRE Transactions on Human Factors in Electronics.</i> <b>2</b> pp. 3-8.</li>
<li><a href="/wiki/John_McCarthy_%28computer_scientist%29" title="John McCarthy (computer scientist)">McCarthy, John</a> (1960). Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I. <i><a href="/wiki/Communications_of_the_ACM" title="Communications of the ACM">Communications of the ACM</a></i>. <small><a href="http://www-formal.stanford.edu/jmc/recursive.html" class="external autonumber" title="http://www-formal.stanford.edu/jmc/recursive.html" rel="nofollow">[1]</a> <a href="http://www-formal.stanford.edu/jmc/recursive/recursive.html" class="external text" title="http://www-formal.stanford.edu/jmc/recursive/recursive.html" rel="nofollow">HTML</a> <a href="http://www-formal.stanford.edu/jmc/recursive.dvi" class="external text" title="http://www-formal.stanford.edu/jmc/recursive.dvi" rel="nofollow">DVI</a> <a href="http://www-formal.stanford.edu/jmc/recursive.pdf" class="external text" title="http://www-formal.stanford.edu/jmc/recursive.pdf" rel="nofollow">PDF</a> <a href="http://www-formal.stanford.edu/jmc/recursive.ps" class="external text" title="http://www-formal.stanford.edu/jmc/recursive.ps" rel="nofollow">PostScript</a></small></li>
<li><a href="/wiki/Donald_Knuth" title="Donald Knuth">Donald Knuth</a>. <i>Fundamental Algorithms</i>, Third Edition. Addison-Wesley, 1997. <a href="/w/index.php?title=Special:Booksources&amp;isbn=0201896834" class="internal">ISBN 0-201-89683-4</a>. Sections 2.2.3–2.2.5, pp.254–298.</li>
<li><a href="/wiki/Thomas_H._Cormen" title="Thomas H. Cormen">Thomas H. Cormen</a>, <a href="/wiki/Charles_E._Leiserson" title="Charles E. Leiserson">Charles E. Leiserson</a>, <a href="/wiki/Ronald_L._Rivest" title="Ronald L. Rivest">Ronald L. Rivest</a>, and <a href="/wiki/Clifford_Stein" title="Clifford Stein">Clifford Stein</a>. <i><a href="/wiki/Introduction_to_Algorithms" title="Introduction to Algorithms">Introduction to Algorithms</a></i>, Second Edition. MIT Press and McGraw-Hill, 2001. <a href="/w/index.php?title=Special:Booksources&amp;isbn=0262032937" class="internal">ISBN 0-262-03293-7</a>. Section 10.2: Linked lists, pp.204–209.</li>
<li><a href="/wiki/Allen_Newell" title="Allen Newell">Newell, Allen</a> and Shaw, F. C. (1957). Programming the Logic Theory Machine. <i>Proceedings of the Western Joint Computer Conference.</i> pp. 230-240.</li>
<li>Parlante, Nick (2001). Linked list basics. <i>Stanford University</i>. <small><a href="http://cslibrary.stanford.edu/103/LinkedListBasics.pdf" class="external text" title="http://cslibrary.stanford.edu/103/LinkedListBasics.pdf" rel="nofollow">PDF</a></small></li>
<li><a href="/wiki/Robert_Sedgewick_%28computer_scientist%29" title="Robert Sedgewick (computer scientist)">Sedgewick, Robert</a> <i>Algorithms in C</i> (1998). Addison Wesley. <a href="/w/index.php?title=Special:Booksources&amp;isbn=0201314525" class="internal">ISBN 0-201-31452-5</a>, pp. 90–109</li>
<li>Shaffer, Clifford A. <i>A Practical Introduction to Data Structures and Algorithm Analysis</i> (1998). NJ: Prentice Hall. <a href="/w/index.php?title=Special:Booksources&amp;isbn=0136609112" class="internal">ISBN 0-13-660911-2</a>, pp. 77–102</li>
<li><a href="/wiki/Maurice_Vincent_Wilkes" title="Maurice Vincent Wilkes">Wilkes, Maurice Vincent</a> (1964). An Experiment with a Self-compiling Compiler for a Simple List-Processing Language. <i>Annual Review in Automatic Programming</i> <b>4</b>, 1. Published by Pergamon Press.</li>
<li><a href="/wiki/Maurice_Vincent_Wilkes" title="Maurice Vincent Wilkes">Wilkes, Maurice Vincent</a> (1964). Lists and Why They are Useful. <i>Proceeds of the ACM National Conference, Philadelphia 1964</i> (ACM Publication P-64 page F1-1); Also <i>Computer Journal</i> <b>7</b>, 278 (1965).</li>
<li>Kulesh Shanmugasundaram (<a href="/wiki/April_4" title="April 4">April 4</a>, <a href="/wiki/2005" title="2005">2005</a>). <a href="http://isis.poly.edu/kulesh/stuff/src/klist/" class="external text" title="http://isis.poly.edu/kulesh/stuff/src/klist/" rel="nofollow">Linux Kernel Linked List Explained</a>.</li>
</ul>
<p><a name="External_links" id="External_links"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Linked_list&amp;action=edit&amp;section=29" title="Edit section: External links">edit</a>]</span> <span class="mw-headline">External links</span></h2>
<ul>
<li><a href="http://nist.gov/dads/HTML/linkedList.html" class="external text" title="http://nist.gov/dads/HTML/linkedList.html" rel="nofollow">Description</a> from the <a href="/wiki/Dictionary_of_Algorithms_and_Data_Structures" title="Dictionary of Algorithms and Data Structures">Dictionary of Algorithms and Data Structures</a></li>
<li>Some linked list materials are available from the <a href="/wiki/Stanford_University" title="Stanford University">Stanford University</a> Computer Science department:
<ul>
<li><a href="http://cslibrary.stanford.edu/103/" class="external text" title="http://cslibrary.stanford.edu/103/" rel="nofollow">Introduction to Linked Lists</a></li>
<li><a href="http://cslibrary.stanford.edu/105/" class="external text" title="http://cslibrary.stanford.edu/105/" rel="nofollow">Linked List Problems</a></li>
</ul>
</li>
<li><a href="http://mij.oltrelinux.com/devel/simclist/" class="external text" title="http://mij.oltrelinux.com/devel/simclist/" rel="nofollow">SimCList, an open source C library for linked lists</a></li>
<li><a href="http://sglib.sourceforge.net/" class="external text" title="http://sglib.sourceforge.net/" rel="nofollow">SGLib, an collection of algorithms for operating on linked lists (and other containers)</a></li>
<li><a href="http://home.earthlink.net/~jrhay/src/wwwsrc/src.html" class="external text" title="http://home.earthlink.net/~jrhay/src/wwwsrc/src.html" rel="nofollow">Generic List Container Type for ANSI C</a> by <a href="/w/index.php?title=Jeff_Hay&amp;action=edit" class="new" title="Jeff Hay">Jeff Hay</a></li>
<li><a href="http://www.cs.chalmers.se/~noble/manual/sllist.html" class="external text" title="http://www.cs.chalmers.se/~noble/manual/sllist.html" rel="nofollow">shared singly linked list implementations</a></li>
<li><a href="http://www.mycsresource.net/articles/programming/data_structures/linkedlists" class="external text" title="http://www.mycsresource.net/articles/programming/data_structures/linkedlists" rel="nofollow">Linked Lists Tutorial with diagrams and Java code example</a></li>
<li><a href="http://www.google.com/patents?vid=USPAT7028023" class="external text" title="http://www.google.com/patents?vid=USPAT7028023" rel="nofollow">Patent for the idea of having nodes which are in several linked lists simultaneously</a> (note that this technique was widely used for many decades before the patent was granted)</li>
<li><a href="http://jroller.com/page/bobfoster" class="external text" title="http://jroller.com/page/bobfoster" rel="nofollow">Non-patented data structure for having nodes which are in several linked lists simultaneously</a></li>
</ul>

<!-- 
Pre-expand include size: 22150 bytes
Post-expand include size: 5009 bytes
Template argument size: 3443 bytes
Maximum: 2048000 bytes
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:18167-0!1!0!default!!en!2 and timestamp 20070916041355 -->
<div class="printfooter">
Retrieved from "<a href="http://en.wikipedia.org/wiki/Linked_list">http://en.wikipedia.org/wiki/Linked_list</a>"</div>
			<div id="catlinks"><p class='catlinks'><a href="/wiki/Special:Categories" title="Special:Categories">Category</a>: <span dir='ltr'><a href="/wiki/Category:Data_structures" title="Category:Data structures">Data structures</a></span></p></div>			<!-- end content -->
			<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
					 <li id="ca-nstab-main" class="selected"><a href="/wiki/Linked_list" title="View the content page [c]" accesskey="c">Article</a></li>
					 <li id="ca-talk"><a href="/wiki/Talk:Linked_list" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
					 <li id="ca-edit"><a href="/w/index.php?title=Linked_list&amp;action=edit" title="You can edit this page. Please use the preview button before saving. [e]" accesskey="e">Edit this page</a></li>
					 <li id="ca-history"><a href="/w/index.php?title=Linked_list&amp;action=history" title="Past versions of this page [h]" accesskey="h">History</a></li>
				</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a href="/w/index.php?title=Special:Userlogin&amp;returnto=Linked_list" title="You are encouraged to log in, it is not mandatory however. [o]" accesskey="o">Sign in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(/images/wiki-en.png);" href="/wiki/Main_Page" title="Visit the Main Page [z]" accesskey="z"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
		<div class='portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-Main-page"><a href="/wiki/Main_Page">Main page</a></li>
				<li id="n-Contents"><a href="/wiki/Wikipedia:Contents">Contents</a></li>
				<li id="n-Featured-content"><a href="/wiki/Wikipedia:Featured_content">Featured content</a></li>
				<li id="n-currentevents"><a href="/wiki/Portal:Current_events" title="Find background information on current events">Current events</a></li>
				<li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random page [x]" accesskey="x">Random article</a></li>
			</ul>
		</div>
	</div>
		<div class='portlet' id='p-interaction'>
		<h5>interaction</h5>
		<div class='pBody'>
			<ul>
				<li id="n-About-Wikipedia"><a href="/wiki/Wikipedia:About">About Wikipedia</a></li>
				<li id="n-portal"><a href="/wiki/Wikipedia:Community_Portal" title="About the project, what you can do, where to find things">Community portal</a></li>
				<li id="n-recentchanges"><a href="/wiki/Special:Recentchanges" title="The list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
				<li id="n-contact"><a href="/wiki/Wikipedia:Contact_us">Contact Wikipedia</a></li>
				<li id="n-sitesupport"><a href="http://wikimediafoundation.org/wiki/Fundraising" title="Support us">Donate to Wikipedia</a></li>
				<li id="n-help"><a href="/wiki/Help:Contents" title="Guidance on how to use and edit Wikipedia">Help</a></li>
			</ul>
		</div>
	</div>
		<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/wiki/Special:Search" id="searchform"><div>
				<input id="searchInput" name="search" type="text" title="Search Wikipedia [f]" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" />
			</div></form>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="/wiki/Special:Whatlinkshere/Linked_list" title="List of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="/wiki/Special:Recentchangeslinked/Linked_list" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
<li id="t-upload"><a href="/wiki/Wikipedia:Upload" title="Upload images or media files [u]" accesskey="u">Upload file</a></li>
<li id="t-specialpages"><a href="/wiki/Special:Specialpages" title="List of all special pages [q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="/w/index.php?title=Linked_list&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>				<li id="t-permalink"><a href="/w/index.php?title=Linked_list&amp;oldid=157604727" title="Permanent link to this version of the page">Permanent link</a></li><li id="t-cite"><a href="/w/index.php?title=Special:Cite&amp;page=Linked_list&amp;id=157604727">Cite this article</a></li>			</ul>
		</div>
	</div>
	<div id="p-lang" class="portlet">
		<h5>In other languages</h5>
		<div class="pBody">
			<ul>
				<li class="interwiki-be"><a href="http://be.wikipedia.org/wiki/%D0%A1%D1%8C%D0%BF%D1%96%D1%81">Беларуская</a></li>
				<li class="interwiki-cs"><a href="http://cs.wikipedia.org/wiki/Line%C3%A1rn%C3%AD_seznam">Česky</a></li>
				<li class="interwiki-da"><a href="http://da.wikipedia.org/wiki/Liste_%28datastruktur%29">Dansk</a></li>
				<li class="interwiki-de"><a href="http://de.wikipedia.org/wiki/Liste_%28Datenstruktur%29">Deutsch</a></li>
				<li class="interwiki-es"><a href="http://es.wikipedia.org/wiki/Lista_%28estructura_de_datos%29">Español</a></li>
				<li class="interwiki-fr"><a href="http://fr.wikipedia.org/wiki/Liste_cha%C3%AEn%C3%A9e">Français</a></li>
				<li class="interwiki-ko"><a href="http://ko.wikipedia.org/wiki/%EC%97%B0%EA%B2%B0_%EB%A6%AC%EC%8A%A4%ED%8A%B8">한국어</a></li>
				<li class="interwiki-id"><a href="http://id.wikipedia.org/wiki/Linked_list">Bahasa Indonesia</a></li>
				<li class="interwiki-is"><a href="http://is.wikipedia.org/wiki/Tengdur_listi">Íslenska</a></li>
				<li class="interwiki-it"><a href="http://it.wikipedia.org/wiki/Lista_concatenata">Italiano</a></li>
				<li class="interwiki-he"><a href="http://he.wikipedia.org/wiki/%D7%A8%D7%A9%D7%99%D7%9E%D7%94_%D7%9E%D7%A7%D7%95%D7%A9%D7%A8%D7%AA">עברית</a></li>
				<li class="interwiki-lt"><a href="http://lt.wikipedia.org/wiki/Tiesinis_s%C4%85ra%C5%A1as">Lietuvių</a></li>
				<li class="interwiki-hu"><a href="http://hu.wikipedia.org/wiki/L%C3%A1ncolt_lista">Magyar</a></li>
				<li class="interwiki-nl"><a href="http://nl.wikipedia.org/wiki/Gelinkte_lijst">Nederlands</a></li>
				<li class="interwiki-ja"><a href="http://ja.wikipedia.org/wiki/%E7%B7%9A%E5%BD%A2%E3%83%AA%E3%82%B9%E3%83%88">日本語</a></li>
				<li class="interwiki-pl"><a href="http://pl.wikipedia.org/wiki/Lista">Polski</a></li>
				<li class="interwiki-pt"><a href="http://pt.wikipedia.org/wiki/Lista_ligada">Português</a></li>
				<li class="interwiki-ru"><a href="http://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D0%BD%D0%B5%D0%B9%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA">Русский</a></li>
				<li class="interwiki-fi"><a href="http://fi.wikipedia.org/wiki/Linkitetty_lista">Suomi</a></li>
				<li class="interwiki-sv"><a href="http://sv.wikipedia.org/wiki/L%C3%A4nkad_lista">Svenska</a></li>
				<li class="interwiki-uk"><a href="http://uk.wikipedia.org/wiki/%D0%97%D0%B2%27%D1%8F%D0%B7%D0%B0%D0%BD%D0%B8%D0%B9_%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA">Українська</a></li>
				<li class="interwiki-zh"><a href="http://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8">中文</a></li>
			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="/skins-1.5/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>
				<div id="f-copyrightico"><a href="http://wikimediafoundation.org/"><img src="/images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>
			<ul id="f-list">
				<li id="lastmod"> This page was last modified 13:14, 13 September 2007.</li>
				<li id="copyright">All text is available under the terms of the <a class='internal' href="/wiki/Wikipedia:Text_of_the_GNU_Free_Documentation_License" title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal' href="/wiki/Wikipedia:Copyrights" title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the <a href="http://www.wikimediafoundation.org">Wikimedia Foundation, Inc</a>., a U.S. registered <a class='internal' href="/wiki/501%28c%29#501.28c.29.283.29" title="501(c)(3)">501(c)(3)</a> <a href="http://wikimediafoundation.org/wiki/Deductibility_of_donations">tax-deductible</a> <a class='internal' href="/wiki/Non-profit_organization" title="Non-profit organization">nonprofit</a> <a href="/wiki/Charitable_organization" title="Charitable organization">charity</a>.<br /></li>
				<li id="privacy"><a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy policy</a></li>
				<li id="about"><a href="/wiki/Wikipedia:About" title="Wikipedia:About">About Wikipedia</a></li>
				<li id="disclaimer"><a href="/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
		
	
		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
</div>
<!-- Served by srv107 in 0.637 secs. --></body></html>
