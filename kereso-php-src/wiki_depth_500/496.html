<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
				<meta name="keywords" content="Halting problem,1935,1936,1937,Alan Turing,Alfred North Whitehead,Algorithm,Alonzo Church,Alphabet,April 19,Axiomatization" />
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (English)" />
		<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html" />
		<title>Halting problem - Wikipedia, the free encyclopedia</title>
		<style type="text/css" media="screen, projection">/*<![CDATA[*/
			@import "/skins-1.5/common/shared.css?99";
			@import "/skins-1.5/monobook/main.css?99";
		/*]]>*/</style>
		<link rel="stylesheet" type="text/css" media="print" href="/skins-1.5/common/commonPrint.css?99" />
		<!--[if lt IE 5.5000]><style type="text/css">@import "/skins-1.5/monobook/IE50Fixes.css?99";</style><![endif]-->
		<!--[if IE 5.5000]><style type="text/css">@import "/skins-1.5/monobook/IE55Fixes.css?99";</style><![endif]-->
		<!--[if IE 6]><style type="text/css">@import "/skins-1.5/monobook/IE60Fixes.css?99";</style><![endif]-->
		<!--[if IE 7]><style type="text/css">@import "/skins-1.5/monobook/IE70Fixes.css?99";</style><![endif]-->
		<!--[if lt IE 7]><script type="text/javascript" src="/skins-1.5/common/IEFixes.js?99"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
		
		<script type= "text/javascript">/*<![CDATA[*/
var skin = "monobook";
var stylepath = "/skins-1.5";
var wgArticlePath = "/wiki/$1";
var wgScriptPath = "/w";
var wgScript = "/w/index.php";
var wgServer = "http://en.wikipedia.org";
var wgCanonicalNamespace = "";
var wgCanonicalSpecialPageName = false;
var wgNamespaceNumber = 0;
var wgPageName = "Halting_problem";
var wgTitle = "Halting problem";
var wgAction = "view";
var wgRestrictionEdit = [];
var wgRestrictionMove = [];
var wgArticleId = "13668";
var wgIsArticle = true;
var wgUserName = null;
var wgUserGroups = null;
var wgUserLanguage = "en";
var wgContentLanguage = "en";
var wgBreakFrames = false;
var wgCurRevisionId = "156685701";
/*]]>*/</script>
                
		<script type="text/javascript" src="/skins-1.5/common/wikibits.js?99"><!-- wikibits js --></script>
		<script type="text/javascript" src="/w/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook"><!-- site js --></script>
		<style type="text/css">/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Common.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
@import "/w/index.php?title=MediaWiki:Monobook.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
@import "/w/index.php?title=-&action=raw&gen=css&maxage=2678400";
/*]]>*/</style>
		<!-- Head Scripts -->
		<script type="text/javascript" src="/skins-1.5/common/ajax.js?99"></script>
	</head>
<body  class="mediawiki ns-0 ltr page-Halting_problem">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
				<h1 class="firstHeading">Halting problem</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<p>In <a href="/wiki/Computability_theory" title="Computability theory">computability theory</a> the <b>halting problem</b> is a <a href="/wiki/Decision_problem" title="Decision problem">decision problem</a> which can be informally stated as follows:</p>
<dl>
<dd><i>Given a description of a <a href="/wiki/Computer_program" title="Computer program">program</a> and a finite input, decide whether the program finishes running or will run forever, given that input.</i></dd>
</dl>
<p><a href="/wiki/Alan_Turing" title="Alan Turing">Alan Turing</a> proved in 1936 that a general <a href="/wiki/Algorithm" title="Algorithm">algorithm</a> to solve the halting problem for <i>all</i> possible program-input pairs cannot exist. We say that the halting problem is <i><a href="/wiki/Undecidability" title="Undecidability">undecidable</a></i> over <a href="/wiki/Turing_machine" title="Turing machine">Turing machines</a>. (See <sup id="_ref-0" class="reference"><a href="#_note-0" title="">[1]</a></sup> with respect to attribution of the halting problem to Turing.)</p>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a href="#Formal_statement"><span class="tocnumber">1</span> <span class="toctext">Formal statement</span></a></li>
<li class="toclevel-1"><a href="#Importance_and_consequences"><span class="tocnumber">2</span> <span class="toctext">Importance and consequences</span></a></li>
<li class="toclevel-1"><a href="#Sketch_of_proof"><span class="tocnumber">3</span> <span class="toctext">Sketch of proof</span></a></li>
<li class="toclevel-1"><a href="#Common_pitfalls"><span class="tocnumber">4</span> <span class="toctext">Common pitfalls</span></a></li>
<li class="toclevel-1"><a href="#Formalization_of_the_halting_problem"><span class="tocnumber">5</span> <span class="toctext">Formalization of the halting problem</span></a></li>
<li class="toclevel-1"><a href="#Relationship_with_G.C3.B6del.27s_incompleteness_theorem"><span class="tocnumber">6</span> <span class="toctext">Relationship with Gödel's incompleteness theorem</span></a></li>
<li class="toclevel-1"><a href="#Can_humans_solve_the_halting_problem.3F"><span class="tocnumber">7</span> <span class="toctext">Can humans solve the halting problem?</span></a></li>
<li class="toclevel-1"><a href="#Recognizing_partial_solutions"><span class="tocnumber">8</span> <span class="toctext">Recognizing partial solutions</span></a></li>
<li class="toclevel-1"><a href="#History_of_the_halting_problem"><span class="tocnumber">9</span> <span class="toctext">History of the halting problem</span></a></li>
<li class="toclevel-1"><a href="#See_also"><span class="tocnumber">10</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1"><a href="#Humor"><span class="tocnumber">11</span> <span class="toctext">Humor</span></a></li>
<li class="toclevel-1"><a href="#Footnotes"><span class="tocnumber">12</span> <span class="toctext">Footnotes</span></a></li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">13</span> <span class="toctext">References</span></a></li>
</ul>
</td>
</tr>
</table>
<script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script>
<p><a name="Formal_statement" id="Formal_statement"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Halting_problem&amp;action=edit&amp;section=1" title="Edit section: Formal statement">edit</a>]</span> <span class="mw-headline">Formal statement</span></h2>
<p>A <a href="/wiki/Decision_problem" title="Decision problem">decision problem</a> is a set of natural numbers; the "problem" is to determine whether a particular number is in the set.</p>
<p>Given a <a href="/wiki/G%C3%B6del_numbering" title="Gödel numbering">Gödel numbering</a> <img class="tex" alt="\varphi" src="http://upload.wikimedia.org/math/3/5/3/3538eb9c84efdcbd130c4c953781cfdb.png" /> of the <a href="/wiki/Computable_function" title="Computable function">computable functions</a> (such as Turing's <a href="/wiki/Description_number" title="Description number">description numbers</a>) and a <a href="/wiki/Pairing_function" title="Pairing function">pairing function</a> <img class="tex" alt="\langle i, x \rangle" src="http://upload.wikimedia.org/math/b/5/c/b5cb2eb96fc9667c99cba3480795849e.png" />, the <b>halting problem</b> (also called the <b>halting set</b>) is the decision problem for the set</p>
<dl>
<dd><img class="tex" alt="K_{\varphi}^{0}&#160;:= \{ \langle i, x \rangle | \varphi_i(x) \ \mathrm{exists} \}" src="http://upload.wikimedia.org/math/9/2/e/92e1e4d6548f1b31a4d8029a6f2b1553.png" /></dd>
</dl>
<p>with <img class="tex" alt="\varphi_i" src="http://upload.wikimedia.org/math/c/2/2/c2206da5a1fb2b0aa0b9c6371a850e61.png" /> the <i>i</i>-th computable function under the Gödel numbering <img class="tex" alt="\varphi" src="http://upload.wikimedia.org/math/3/5/3/3538eb9c84efdcbd130c4c953781cfdb.png" />.</p>
<p>Although the set <i>K</i> is <a href="/wiki/Recursively_enumerable" title="Recursively enumerable">recursively enumerable</a>, the halting problem is not solvable by a computable function.</p>
<p>There are many equivalent formulations of the Halting problem; any set whose <a href="/wiki/Turing_degree" title="Turing degree">Turing degree</a> is the same as that of the Halting problem can be thought of as such a formulation. Examples of such sets include:</p>
<ul>
<li><img class="tex" alt="\{ i \mid \varphi_i(0) \ \mathrm{halts} \}" src="http://upload.wikimedia.org/math/4/d/b/4db7e7aa67d7e14beb2241754768721c.png" /></li>
<li><img class="tex" alt="\{ i \mid \exists n ( \varphi_i(n) \ \mathrm{halts})\}." src="http://upload.wikimedia.org/math/a/9/0/a90becf4ca758c8d52bbddc21137b826.png" /></li>
</ul>
<p><a name="Importance_and_consequences" id="Importance_and_consequences"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Halting_problem&amp;action=edit&amp;section=2" title="Edit section: Importance and consequences">edit</a>]</span> <span class="mw-headline">Importance and consequences</span></h2>
<p>The historical importance of the halting problem lies in the fact that it was one of the first problems to be proved <a href="/wiki/Undecidable" title="Undecidable">undecidable</a>. (Turing's proof went to press in May 1936, whereas <a href="/wiki/Alonzo_Church" title="Alonzo Church">Church</a>'s proof of the undecidability of a problem in the <a href="/wiki/Lambda_calculus" title="Lambda calculus">lambda calculus</a> had already been published in April 1936.) Subsequently, many other such problems have been described; the typical method of proving a problem to be undecidable is with the technique of <i><a href="/wiki/Reduction_%28complexity%29" title="Reduction (complexity)">reduction</a></i>. To do this, the computer scientist shows that if a solution to the new problem was found, it could be used to decide an undecidable problem (by transforming instances of the undecidable problem into instances of the new problem). Since we already know that <i>no</i> method can decide the old problem, no method can decide the new problem either.</p>
<p>One such consequence of the halting problem's undecidability is that there cannot be a general <a href="/wiki/Algorithm" title="Algorithm">algorithm</a> that decides whether a given statement about <a href="/wiki/Natural_number" title="Natural number">natural numbers</a> is true or not. The reason for this is that the <a href="/wiki/Proposition" title="Proposition">proposition</a> stating that a certain algorithm will halt given a certain input can be converted into an equivalent statement about natural numbers. If we had an algorithm that could solve every statement about natural numbers, it could certainly solve this one; but that would determine whether the original program halts, which is impossible, since the halting problem is undecidable.</p>
<p>Yet another consequence of the undecidability of the halting problem is <a href="/wiki/Rice%27s_theorem" title="Rice's theorem">Rice's theorem</a> which states that the truth of <i>any</i> non-trivial statement about the function that is defined by an algorithm is undecidable. So, for example, the decision problem "will this algorithm halt for the input 0" is already undecidable. Note that this theorem holds for the <i>function defined by the algorithm</i> and not the algorithm itself. It is, for example, quite possible to decide if an algorithm will halt within 100 steps, but this is not a statement about the function that is defined by the algorithm.</p>
<p><a href="/wiki/Gregory_Chaitin" title="Gregory Chaitin">Gregory Chaitin</a> has defined a <a href="/wiki/Halting_probability" title="Halting probability">halting probability</a>, represented by the symbol Ω, a type of real number that informally is said to represent the <a href="/wiki/Probability" title="Probability">probability</a> that a randomly produced program halts. These numbers have the same <a href="/wiki/Turing_degree" title="Turing degree">Turing degree</a> as the halting problem. It is a <a href="/wiki/Normal_number" title="Normal number">normal</a> and <a href="/wiki/Transcendental_number" title="Transcendental number">transcendental</a> number which can be <a href="/wiki/Definable_number" title="Definable number">defined</a> but cannot be completely <a href="/wiki/Computable_number" title="Computable number">computed</a>. This means one can prove that there is no <a href="/wiki/Algorithm" title="Algorithm">algorithm</a> which produces the digits of Ω, although its first few digits can be calculated in simple cases.</p>
<p>While Turing's proof shows that there can be no general method or algorithm to determine whether algorithms halt, individual instances of that problem may very well be susceptible to attack. Given a specific algorithm, one can often show that it must halt for any input, and in fact <a href="/wiki/Computer_scientist" title="Computer scientist">computer scientists</a> often do just that as part of a <a href="/wiki/Correctness_proof" title="Correctness proof">correctness proof</a>. But each proof has to be developed specifically for the algorithm at hand; there is no <i>mechanical, general way</i> to determine whether algorithms on a Turing machine halt. However, there are some <a href="/wiki/Heuristic_%28computer_science%29" title="Heuristic (computer science)">heuristics</a> that can be used in an automated fashion to attempt to construct a proof, which succeed frequently on typical programs. This field of research is known as automated <a href="/wiki/Termination_analysis" title="Termination analysis">termination analysis</a>.</p>
<p>Turing's introduction of the machine model that has become known as the <a href="/wiki/Turing_machine" title="Turing machine">Turing machine</a>, introduced in the paper, has proven a convenient model for much <a href="/wiki/Theoretical_computer_science" title="Theoretical computer science">theoretical computer science</a> since.</p>
<p><a name="Sketch_of_proof" id="Sketch_of_proof"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Halting_problem&amp;action=edit&amp;section=3" title="Edit section: Sketch of proof">edit</a>]</span> <span class="mw-headline">Sketch of proof</span></h2>
<p>The method of proof is <a href="/wiki/Reductio_ad_absurdum" title="Reductio ad absurdum">reductio ad absurdum</a>. You are given a programming language, a scheme that associates every program that is realizable on a Turing machine with a string that describes that program. Suppose that someone claims to have found a program <tt>halt(p, i)</tt> that returns <tt><b>true</b></tt> if the string <i>p</i> describes a program that halts when given as input the string <i>i</i>, and returns <tt><b>false</b></tt> if <i>p</i> describes a program that does not halt on <i>i</i>. The remainder of the proof shows how to construct a program on which <tt>halt</tt> cannot behave as claimed.</p>
<p>If two programs are realizable on a <a href="/wiki/Turing_machine" title="Turing machine">Turing machine</a>, then executing both of them in sequence is also realizable, and so is executing one depending on a condition. This means that you can construct a program called <tt>trouble</tt>, taking one input, that does the following:</p>
<ol>
<li>Duplicate the input.</li>
<li>Apply <tt>halt</tt> to the two copies of the input.</li>
<li>If <tt>halt</tt> returned <b>true</b>, then loop forever.</li>
</ol>
<p>Since all programs have string descriptions, there is a string <i>t</i> that represents the program <tt>trouble</tt>. Does <tt>trouble</tt> halt when its input is <i>t</i>?</p>
<p>Consider both cases:</p>
<ul>
<li>If <tt>trouble(t)</tt> halts, it must be because <tt>halt(t, t)</tt> returned <tt><b>false</b></tt>, but that would mean that <tt>trouble(t)</tt> should not have halted.</li>
<li>If <tt>trouble(t)</tt> runs forever, it is either because <tt>halt</tt> itself runs forever, or because it returned <tt><b>true</b></tt>. This would mean either that <tt>halt</tt> does not give an answer for every program and input, or that <tt>trouble(t)</tt> should have halted.</li>
</ul>
<p>Either case concludes that <tt>halt</tt> did not give a correct answer, contrary to the original claim. Since the same reasoning applies to <i>any</i> program that someone might offer as a solution to the halting problem, there can be no solution.</p>
<p>This classic proof is typically referred to as the <b>diagonalization proof</b>, so called because if one imagines a grid containing all the values of <tt>halt(p, i)</tt>, with every possible <i>p</i> value given its own row, and every possible <i>i</i> value given its own column, then the values of <tt>halt(s, s)</tt> are arranged along the main diagonal of this grid. The proof can be framed in the form of the question: what row of the grid corresponds to the string <i>t</i>? The answer is that the <tt>trouble</tt> function is devised such that <tt>halt(t, i)</tt> differs from every row in the grid in at least one position: namely, the main diagonal, where <i>t</i>=<i>i</i>. This contradicts the requirement that the grid contains a row for every possible <i>p</i> value, and therefore constitutes a <a href="/wiki/Reductio_ad_absurdum" title="Reductio ad absurdum">proof by contradiction</a> that the halting problem is undecidable.</p>
<p><a name="Common_pitfalls" id="Common_pitfalls"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Halting_problem&amp;action=edit&amp;section=4" title="Edit section: Common pitfalls">edit</a>]</span> <span class="mw-headline">Common pitfalls</span></h2>
<p>Many students, upon analyzing the above proof, ask whether there might be an algorithm that can return a third option for some programs, such as "undecidable" or "would lead to a contradiction." This reflects a misunderstanding of decidability. It is easy to construct one algorithm that always answers "halts" and another that always answers "doesn't halt." For any <i>specific</i> program and input, one of these two algorithms answers correctly, even though nobody may know which one. The difficulty of the halting problem lies not in particular programs, but in the requirement that a solution must work for all programs.</p>
<p>There are programs (<a href="/wiki/Interpreter_%28computing%29" title="Interpreter (computing)">interpreters</a>) that simulate the execution of whatever source code they are given. Such programs can demonstrate that a program does halt if this is already known to be the case. However, an interpreter will not halt if its input program does not halt, so this approach cannot solve the halting problem as stated.</p>
<p>The halting problem is, <i>in theory</i> if not in practice, decidable for deterministic machines with finite memory. A machine with finite memory has a finite number of states, and thus any deterministic program on it must eventually either halt or repeat a previous state:</p>
<dl>
<dd>"...<i>any finite-state machine, if left completely to itself, will fall eventually into a perfectly periodic repetitive pattern</i>. The duration of this repeating pattern cannot exceed the number of internal states of the machine..."(italics in original, Minsky 1967, p. 24)</dd>
</dl>
<p>Minsky warns us, however, that machines such as computers with e.g. a million small parts, each with two states, will have on the order of 2^1,000,000 possible states:</p>
<dl>
<dd>"This is a 1 followed by about three hundred thousand zeroes ... Even if such a machine were to operate at the frequencies of cosmic rays, the aeons of galactic evolution would be as nothing compared to the time of a journey through such a cycle" (Minsky p. 25)</dd>
</dl>
<p>Minsky exhorts the reader to be suspicious -- although a machine may be finite, and finite automata "have a number of theoretical limitations":</p>
<dl>
<dd>"...the magnitudes involved should lead one to suspect that theorems and arguments based chiefly on the mere finiteness [of] the state diagram may not carry a great deal of significance" (ibid).</dd>
</dl>
<p>For more on this issue of "intractability" see the article <a href="/wiki/Busy_beaver" title="Busy beaver">Busy beaver</a>.</p>
<p>It can also be decided automatically whether a nondeterministic machine with finite memory halts on no, some, or all possible sequences of nondeterministic decisions, by enumerating states after each possible decision.</p>
<p><a name="Formalization_of_the_halting_problem" id="Formalization_of_the_halting_problem"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Halting_problem&amp;action=edit&amp;section=5" title="Edit section: Formalization of the halting problem">edit</a>]</span> <span class="mw-headline">Formalization of the halting problem</span></h2>
<p>In his original proof Turing formalized the concept of <i><a href="/wiki/Algorithm" title="Algorithm">algorithm</a></i> by introducing <a href="/wiki/Turing_machine" title="Turing machine">Turing machines</a>. However, the result is in no way specific to them; it applies equally to any other model of <a href="/wiki/Computation" title="Computation">computation</a> that is equivalent in its computational power to Turing machines, such as <a href="/wiki/Markov_algorithm" title="Markov algorithm">Markov algorithms</a>, <a href="/wiki/Lambda_calculus" title="Lambda calculus">Lambda calculus</a>, <a href="/wiki/Post_system" title="Post system">Post systems</a> or <a href="/wiki/Register_machine" title="Register machine">register machines</a>.</p>
<p>What is important is that the formalization allows a straightforward <a href="/wiki/Mapping" title="Mapping">mapping</a> of algorithms to some <a href="/wiki/Data_type" title="Data type">data type</a> that the <a href="/wiki/Algorithm" title="Algorithm">algorithm</a> can operate upon. For example, if the <a href="/wiki/Formalism" title="Formalism">formalism</a> lets algorithms define functions over strings (such as Turing machines) then there should be a mapping of these algorithms to strings, and if the formalism lets algorithms define functions over natural numbers (such as <a href="/wiki/Computable_function" title="Computable function">computable functions</a>) then there should be a mapping of algorithms to natural numbers. The mapping to strings is usually the most straightforward, but strings over an <a href="/wiki/Alphabet" title="Alphabet">alphabet</a> with <i>n</i> <a href="/wiki/Character_%28computing%29" title="Character (computing)">characters</a> can also be mapped to numbers by interpreting them as numbers in an <i>n</i>-ary <a href="/wiki/Numeral_system" title="Numeral system">numeral system</a>.</p>
<p><a name="Relationship_with_G.C3.B6del.27s_incompleteness_theorem" id="Relationship_with_G.C3.B6del.27s_incompleteness_theorem"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Halting_problem&amp;action=edit&amp;section=6" title="Edit section: Relationship with Gödel's incompleteness theorem">edit</a>]</span> <span class="mw-headline">Relationship with Gödel's incompleteness theorem</span></h2>
<p>The <a href="/wiki/Concept" title="Concept">concepts</a> raised by <a href="/wiki/G%C3%B6del%27s_incompleteness_theorem" title="Gödel's incompleteness theorem">Gödel's incompleteness theorems</a> are very similar to those raised by the halting problem, and the proofs are quite similar. In fact, a weaker form of the First Incompleteness Theorem is an easy consequence of the undecidability of the halting problem. This weaker form differs from the standard statement of the incompleteness theorem by asserting that a complete, <a href="/wiki/Consistency_proof" title="Consistency proof">consistent</a> and <a href="/wiki/Soundness" title="Soundness">sound</a> <a href="/wiki/Axiomatization" title="Axiomatization">axiomatization</a> of all statements about natural numbers is unachievable. The "sound" part is the weakening: it means that we require the axiomatic system in question to prove only <i>true</i> statements about natural numbers (it's very important to observe that the statement of the standard form of Gödel's First Incompleteness Theorem is completely unconcerned with the question of truth, but only concerns the issue of whether it can be <a href="/wiki/Mathematical_proof" title="Mathematical proof">proven</a>).</p>
<p>The weaker form of the theorem can be proved from the undecidability of the halting problem as follows. Assume that we have a consistent and complete <a href="/wiki/Axiomatization" title="Axiomatization">axiomatization</a> of all true <a href="/wiki/First-order_logic" title="First-order logic">first-order logic</a> statements about <a href="/wiki/Natural_number" title="Natural number">natural numbers</a>. Then we can build an algorithm that enumerates all these statements. This means that there is an algorithm <i>N</i>(<i>n</i>) that, given a natural number <i>n</i>, computes a true first-order logic statement about natural numbers such that, for all the true statements, there is at least one <i>n</i> such that <i>N</i>(<i>n</i>) yields that statement. Now suppose we want to decide if the algorithm with representation <i>a</i> halts on input <i>i</i>. We know that this statement can be expressed with a first-order logic statement, say <i>H</i>(<i>a</i>, <i>i</i>). Since the axiomatization is complete it follows that either there is an <i>n</i> such that <i>N</i>(<i>n</i>) = <i>H</i>(<i>a</i>, <i>i</i>) or there is an <i>n'</i> such that <i>N</i>(<i>n'</i>) = ¬ <i>H</i>(<i>a</i>, <i>i</i>). So if we <a href="/wiki/Iterate" title="Iterate">iterate</a> over all <i>n</i> until we either find <i>H</i>(<i>a</i>, <i>i</i>) or its negation, we will always halt. This means that this gives us an algorithm to decide the halting problem. Since we know that there cannot be such an algorithm, it follows that the assumption that there is a consistent and complete axiomatization of all true first-order logic statements about natural numbers must be false.</p>
<p><a name="Can_humans_solve_the_halting_problem.3F" id="Can_humans_solve_the_halting_problem.3F"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Halting_problem&amp;action=edit&amp;section=7" title="Edit section: Can humans solve the halting problem?">edit</a>]</span> <span class="mw-headline">Can humans solve the halting problem?</span></h2>
<p>It might seem like <a href="/wiki/Human" title="Human">humans</a> could solve the halting problem. After all, a <a href="/wiki/Programmer" title="Programmer">programmer</a> can often look at a <a href="/wiki/Computer_program" title="Computer program">program</a> and tell whether it will halt. It is useful to understand why this cannot be true. For <a href="/wiki/Simplicity" title="Simplicity">simplicity</a>, we will consider the halting problem for programs with no <a href="/wiki/Input" title="Input">input</a>, which is also undecidable.</p>
<p>To "solve" the halting problem means to be able to look at <i>any</i> program and tell whether it halts. It is not enough to be able to look at <i>some</i> programs and decide. Humans may also not be able to solve the halting problem, due to the sheer size of the input (a program with millions of lines of code). Even for short programs, it isn't clear that humans can always tell whether they halt. For example, we might ask if this pseudocode function, which corresponds to a particular Turing machine, ever halts:</p>
<pre>
 <b>function</b> searchForOddPerfectNumber()
     <b>var</b> <i>int</i> n = 1     <i>// arbitrary-precision integer</i>
     <b>loop</b> {
         <b>var</b> <i>int</i> sumOfFactors = 0
         <b>for</b> factor <b>from</b> 1 <b>to</b> n - 1 {
             <b>if</b> factor is a factor of n <b>then</b>
                 sumOfFactors = sumOfFactors + factor
         }
         <b>if</b> sumOfFactors = n <b>then</b>
             <b>exit loop</b>
         n = n + 2
     }
     <b>return</b>
</pre>
<p>This program searches until it finds an odd <a href="/wiki/Perfect_number" title="Perfect number">perfect number</a>, then halts. It halts if and only if such a <a href="/wiki/Number" title="Number">number</a> exists, which is a major <a href="/wiki/Unsolved_problems_in_mathematics" title="Unsolved problems in mathematics">open question</a> in <a href="/wiki/Mathematics" title="Mathematics">mathematics</a>. So, after centuries of work, <a href="/wiki/Mathematician" title="Mathematician">mathematicians</a> have yet to discover whether a simple, ten-line program halts. This makes it difficult to see how humans could solve the halting problem.</p>
<p>More generally, it's usually easy to see how to write a simple brute-force search program that looks for counterexamples to any particular conjecture in number theory; if the program finds a counterexample, it stops and prints out the counterexample, and otherwise it keeps searching forever. For example, consider the famous (and still unsolved) <a href="/wiki/Twin_prime_conjecture" title="Twin prime conjecture">twin prime conjecture</a>. This asks whether there are arbitrarily large prime numbers <i>p</i> and <i>q</i> with <i>p</i>+2 = <i>q</i>. Now consider the following program, which accepts an input <i>N</i>:</p>
<pre>
 <b>function</b> findTwinPrimeAbove(<i>int</i> N)
     <i>int</i> p = N
     <b>loop</b>
         <b>if</b> p is prime <b>and</b> p + 2 is prime <b>then</b>
             <b>return</b>
         <b>else</b>
             p = p + 1
</pre>
<p>This program searches for twin primes <i>p</i> and <i>p</i>+2 both at least as large as <i>N</i>. If there are arbitrarily large twin primes, it will halt for all possible inputs. But if there is a largest pair of twin primes <i>P</i> and <i>P</i>+2, then the program will never halt if it is given an input <i>N</i> larger than <i>P</i>. Thus if we could answer the question of whether this program halts on all inputs, we would have the long-sought answer to the twin prime conjecture. It's similarly straightforward to write programs which halt depending on the truth or falsehood for many other conjectures of <a href="/wiki/Number_theory" title="Number theory">number theory</a>.</p>
<p>Because of this, one might say that the unsolvability of the halting problem is unsurprising. If there were a mechanical way to decide whether arbitrary programs would halt, then many apparently difficult mathematical problems would succumb to it. A counterargument to this, however, is that even if the halting problem were decidable over Turing machines, as it is over physical computers and other <a href="/wiki/Linear_bounded_automaton" title="Linear bounded automaton">LBAs</a>, it might still be infeasible in practice because it takes too much time or memory to execute. For example, there are some very large upper bounds on numbers with certain properties in number theory (the predominant example of this being <a href="/wiki/Graham%27s_number" title="Graham's number">Graham's number</a>), but it's not feasible to check all values below this bound in a naïve way with a computer — they can't even hold some of these numbers in memory.</p>
<p><a name="Recognizing_partial_solutions" id="Recognizing_partial_solutions"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Halting_problem&amp;action=edit&amp;section=8" title="Edit section: Recognizing partial solutions">edit</a>]</span> <span class="mw-headline">Recognizing partial solutions</span></h2>
<p>There are many programs that either return a correct answer to the halting problem or do not return an answer at all. If it were possible to decide whether a program gives only correct answers, one might hope to collect a large number of such programs and run them in parallel, in the hope of being able to determine whether any programs halt. However, recognizing such partial halting solvers (PHS) is just as hard as the halting problem itself.</p>
<p>Suppose someone claims that program PHSR is a partial halting solver recognizer. Construct a program H:</p>
<pre>
input a program P
X := "input Q. <b>if</b> Q = P output 'halts' <b>else</b> loop forever"
run PHSR with X as input
</pre>
<p>If PHSR recognizes the constructed program X as a partial halting solver, that means that P, the only input for which X produces a result, halts. If PHSR fails to recognize X, then it must be because P does not halt. Therefore H can decide whether an arbitrary program P halts; it solves the halting problem. Since this is impossible, the program PHSR could not have been a partial halting solver recognizer as claimed. Therefore no program can be a partial halting solver recognizer.</p>
<p>Another example, <i>H<sub>T</sub></i>, of a <a href="/wiki/Turing_machine" title="Turing machine">Turing machine</a> which gives correct answers only for <i>some</i> instances of the halting problem can be described by the requirements that, if <i>H<sub>T</sub></i> is started scanning a field which carries the first of a finite string of <i>a</i> consecutive "1"s, followed by one field with symbol "0" (i.&#160;e. a blank field), and followed in turn by a finite string of <i>i</i> consecutive "1"s, on an otherwise blank tape, then</p>
<ul>
<li><i>H<sub>T</sub></i> halts for any such starting state, i.&#160;e. for any input of finite positive integers <i>a</i> and <i>i</i>;</li>
<li><i>H<sub>T</sub></i> halts on a completely <i>blank</i> tape if and only if the Turing machine represented by <i>a</i> does not halt when given the starting state and input represented by <i>i</i>; and</li>
<li><i>H<sub>T</sub></i> halts on a <i>nonblank</i> tape, scanning an appropriate field (which however does not necessarily carry the symbol "1") if and only if the Turing machine represented by <i>a</i> does halt when given the starting state and input represented by <i>i</i>. In this case, the final state in which <i>H<sub>T</sub></i> halted (contents of the tape, and field being scanned) shall be equal to some particular intermediate state which the Turing machine represented by <i>a</i> attains when given the starting state and input represented by <i>i</i>; or, if all those intermediate states (including the starting state represented by <i>i</i>) leave the tape blank, then the final state in which <i>H<sub>T</sub></i> halted shall be scanning a "1" on an otherwise blank tape.</li>
</ul>
<p>While its existence has not been refuted (essentially: because there's no Turing machine which would halt <i>only</i> if started on a blank tape), such a Turing machine <i>H<sub>T</sub></i> would solve the halting problem only <i>partially</i> either (because it doesn't necessarily scan the symbol "1" in the final state, if the Turing machine represented by <i>a</i> does halt when given the starting state and input represented by <i>i</i>, as explicit statements of the halting problem for Turing machines may require).</p>
<p><a name="History_of_the_halting_problem" id="History_of_the_halting_problem"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Halting_problem&amp;action=edit&amp;section=9" title="Edit section: History of the halting problem">edit</a>]</span> <span class="mw-headline">History of the halting problem</span></h2>
<p>In the following: U refers to the source "Undecidable".</p>
<dl>
<dd><i>For more see <a href="/wiki/Algorithm#History:_Development_of_the_notion_of_.22algorithm.22" title="Algorithm">History</a>.</i></dd>
</dl>
<p>1900 -- <a href="/wiki/Hilbert" title="Hilbert">Hilbert</a> poses his "23 questions" cf <a href="/wiki/Hilbert_problems" title="Hilbert problems">Hilbert problems</a> at the Second <a href="/wiki/International_Congress_of_Mathematicians" title="International Congress of Mathematicians">International Congress of Mathematicians</a> in Paris, "Of these, the second was that of proving the consistency of the '<a href="/wiki/Peano_axioms" title="Peano axioms">Peano axioms</a>' on which, as he had shown, the rigour of mathematics depended" (Hodges p. 83, Davis' commentary in U p. 108).</p>
<p>1928 -- <a href="/wiki/Hilbert" title="Hilbert">Hilbert</a> recasts his 'Second Problem' at the Bologna International Congress (cf Reid pp. 188-189). Hodges claims he posed three questions: i.e. #1: Was mathematics <i>complete</i>? #2: Was mathematics <i>consistent</i>? #3: Was mathematics <i>decidable</i>? (Hodges p. 91). The third question is known as the <i><a href="/wiki/Entscheidungsproblem" title="Entscheidungsproblem">Entscheidungsproblem</a></i> (Decision Problem) (Hodges p. 91, Penrose p. 34)</p>
<p>1930 -- <a href="/wiki/G%C3%B6del" title="Gödel">Gödel</a> announces a proof as an answer to the first two of Hilbert's 1928 questions [cf Reid p. 198]. "At first he [Hilbert] was only angry and frustrated, but then he began to try to deal constructively with the problem... Gödel himself felt -- and expressed the thought in his paper -- that his work did not contradict Hilbert's formalistic point of view" (Reid p. 199).</p>
<p>1931 -- The paper of <a href="/wiki/Kurt_G%C3%B6del" title="Kurt Gödel">Kurt Gödel</a> appears: "On Formally Undecidable Propositions of Principia Mathematica and Related Systems I", (reprinted in U p. 5ff)</p>
<p><a href="/wiki/April_19" title="April 19">19 April</a> <a href="/wiki/1935" title="1935">1935</a> -- Paper of <a href="/wiki/Alonzo_Church" title="Alonzo Church">Alonzo Church</a> "An Unsolvable Problem of Elementary Number Theory" identifies what it means for a function to <i>effective calculable</i>. Such a function will have an algorithm, and "...the fact that the algorithm has <i>terminated</i> becomes effectively known ..." (italics added, U p. 100).</p>
<p>1936 -- <a href="/wiki/Alonzo_Church" title="Alonzo Church">Alonzo Church</a> publishes the first proof that the <i>Entscheidungsproblem</i> is unsolvable [<i>A Note on the Entscheidungsproblem</i>, reprinted in U p. 110].</p>
<p>7 October <a href="/wiki/1936" title="1936">1936</a> -- <a href="/wiki/Emil_Post" title="Emil Post">Emil Post</a>'s paper "Finite Combinatory Processes. Formulation I" is received. Post adds to his "process" an instruction "(C) Stop". He called such a process "type 1 ... if the process it determines terminates for each specific problem." (U. p.289ff)</p>
<p><a href="/wiki/1937" title="1937">1937</a>-- <a href="/wiki/Alan_Turing" title="Alan Turing">Alan Turing</a>'s paper <i>On Computable Numbers With an Application to the Entscheidungsproblem</i> reaches print in January 1937 (reprinted in U, p. 115). Turing's proof departs from calculation by <a href="/wiki/Recursive_functions" title="Recursive functions">recursive functions</a> and introduces the notion of computation by machine. Stephen Kleene (1952) refers to this as one of the "first examples of decision problems proved unsolvable".</p>
<p>1939 -- J.B. <a href="/wiki/Rosser" title="Rosser">Rosser</a> observes the essential equivalence of "effective method" defined by Gödel, Church, and Turing (Rosser in U p. 273, "Informal Exposition of Proofs of Gödel's Theorem and Church's Theorem").</p>
<p>1943 -- In his 1943 paper <a href="/wiki/Stephen_Kleene" title="Stephen Kleene">Stephen Kleene</a> states that "In setting up a complete algorithmic theory, what we do is describe a procedure ... which procedure necessarily terminates and in such manner that from the outcome we can read a definite answer, "Yes" or "No," to the question, "Is the predicate value true?"."</p>
<p>1952 -- <a href="/wiki/Stephen_Kleene" title="Stephen Kleene">Stephen Kleene</a> (1952) Chapter XIII ("Computable Functions") includes a discussion of the unsolvability of the halting problem for Turing machines and reformulates it in terms of machines that "eventually stop", i.e. halt: "... there is no algorithm for deciding whether any given machine, when started from any given situation, <i>eventually <b>stops</b></i>." (Kleene (1952) p.382)</p>
<p>1952 -- "Davis [ <a href="/wiki/Martin_Davis" title="Martin Davis">Martin Davis</a> ] thinks it likely that he first used the term 'halting problem' in a series of lectures that he gave at the Control Systems Laboratory at the University of Illinois in 1952 (letter from Davis to Copeland, 12 Dec. 2001.)" (Footnote 61 in Copeland (2004) pp.40ff)</p>
<p><a name="See_also" id="See_also"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Halting_problem&amp;action=edit&amp;section=10" title="Edit section: See also">edit</a>]</span> <span class="mw-headline">See also</span></h2>
<ul>
<li><a href="/wiki/Worst-case_execution_time" title="Worst-case execution time">Worst-case execution time</a></li>
</ul>
<p><a name="Humor" id="Humor"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Halting_problem&amp;action=edit&amp;section=11" title="Edit section: Humor">edit</a>]</span> <span class="mw-headline">Humor</span></h2>
<p><a href="/wiki/Larry_Wall" title="Larry Wall">Larry Wall</a> once remarked, "It's easy to solve the halting problem with a shotgun." (Larry Wall in &lt;199801151836.KAA14656@wall.org&gt;)</p>
<p><a name="Footnotes" id="Footnotes"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Halting_problem&amp;action=edit&amp;section=12" title="Edit section: Footnotes">edit</a>]</span> <span class="mw-headline">Footnotes</span></h2>
<ol class="references">
<li id="_note-0"><b><a href="#_ref-0" title="">^</a></b> In none of his work did Turing use the word "halting" or "termination". Turing's biographer Hodges does not have the word "halting" or words "halting problem" in his index. The earliest known use of the words "halting problem" is in a proof by Davis (p. 70-71, Davis 1958).
<dl>
<dd>
<dl>
<dd>"Theorem 2.2 <i>There exists a Turing machine whose halting problem is recursively unsolvable</i>.</dd>
</dl>
</dd>
<dd>"A related problem is the <i>printing problem</i> for a simple Turing machine Z with respect to a symbol S<sub>i</sub>" (p. 70).</dd>
</dl>
Davis adds no attribution for his proof, so one infers that it is original with him. But Davis has pointed out that a statement of the proof exists informally in Kleene (1952) on page 382. Copeland (2004) states that:
<dl>
<dd>"The halting problem was so named (and it appears, first stated) by Martin Davis [cf Copeland footnote 61]... (It is often said that Turing stated and proved the halting theorem in 'On Computable Numbers', but strictly this is not true)." (p. 40)</dd>
<dd><i>For more see the <b>History</b> section above.</i></dd>
</dl>
</li>
</ol>
<p><a name="References" id="References"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Halting_problem&amp;action=edit&amp;section=13" title="Edit section: References">edit</a>]</span> <span class="mw-headline">References</span></h2>
<ul>
<li><a href="/wiki/Alan_Turing" title="Alan Turing">Alan Turing</a>, <i>On computable numbers, with an application to the Entscheidungsproblem</i>, Proceedings of the London Mathematical Society, Series 2, 42 (1936), pp 230-265. <a href="http://www.turingarchive.org/browse.php/B/12" class="external text" title="http://www.turingarchive.org/browse.php/B/12" rel="nofollow">online version</a> This is the epochal paper where Turing defines <a href="/wiki/Turing_machine" title="Turing machine">Turing machines</a>, formulates the halting problem, and shows that it (as well as the <a href="/wiki/Entscheidungsproblem" title="Entscheidungsproblem">Entscheidungsproblem</a>) is unsolvable.</li>
<li><cite class="book" style="font-style:normal" id="Reference-Sipser-2006"><a href="/wiki/Michael_Sipser" title="Michael Sipser">Sipser, Michael</a> (2006). "Section 4.2: The Halting Problem", <i>Introduction to the Theory of Computation</i>, Second Edition, PWS Publishing, pp.173–182. <a href="/w/index.php?title=Special:Booksources&amp;isbn=053494728X" class="internal">ISBN 053494728X</a>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Introduction+to+the+Theory+of+Computation&amp;rft.atitle=Section+4.2%3A+The+Halting+Problem&amp;rft.aulast=Sipser&amp;rft.aufirst=Michael&amp;rft.edition=Second+Edition&amp;rft.pub=PWS+Publishing&amp;rft.pages=pp.173%E2%80%93182">&#160;</span></li>
<li><a href="http://c2.com/cgi/wiki?HaltingProblem" class="extiw" title="wiki:HaltingProblem">Wiki:HaltingProblem</a></li>
<li>B. <a href="/wiki/Jack_Copeland" title="Jack Copeland">Jack Copeland</a> ed. (2004), <i>The Essential Turing: Seminal Writings in Computing, Logic, Philosophy, Artificial Intelligence, and Artificial Life plus The Secrets of Enigma,</i> Clarendon Press (Oxford University Press), Oxford UK, <a href="/w/index.php?title=Special:Booksources&amp;isbn=0198250797" class="internal">ISBN 0-19-825079-7</a>.</li>
<li><a href="/wiki/Martin_Davis" title="Martin Davis">Martin Davis</a>, <i>The Undecidable, Basic Papers on Undecidable Propositions, Unsolvable Problems And Computable Functions</i>, Raven Press, New York, 1965. Turing's paper is #3 in this volume. Papers include those by Godel, Church, Rosser, Kleene, and Post.</li>
<li><a href="/wiki/Martin_Davis" title="Martin Davis">Martin Davis</a>, <i>Computability and Unsolvability</i>, McGraw-Hill, New York, 1958.</li>
<li><a href="/wiki/Alfred_North_Whitehead" title="Alfred North Whitehead">Alfred North Whitehead</a> and <a href="/wiki/Bertrand_Russell" title="Bertrand Russell">Bertrand Russell</a>, <i>Principia Mathematica</i> to *56, Cambridge at the University Press, 1962. Re: the problem of paradoxes, the authors discuss the problem of a set not be an object in any of its "determining functions", in particular "Introduction, Chap. 1 p. 24 "...difficulties which arise in formal logic", and Chap. 2.I. "The Vicious-Circle Principle" p.37ff, and Chap. 2.VIII. "The Contradictions" p. 60ff.</li>
<li><a href="/wiki/Martin_Davis" title="Martin Davis">Martin Davis</a>, "What is a computation", in <i>Mathematics Today</i>, Lynn Arthur Steen, Vintage Books (Random House), 1980. A wonderful little paper, perhaps the best ever written about Turing Machines for the non-specialist. Davis reduces the Turing Machine to a far-simpler model based on Post's model of a computation. Discusses <a href="/wiki/Chaitin" title="Chaitin">Chaitin</a> proof. Includes little biographies of <a href="/wiki/Emil_Post" title="Emil Post">Emil Post</a>, <a href="/wiki/Julia_Robinson" title="Julia Robinson">Julia Robinson</a>.</li>
<li><a href="/wiki/Marvin_Minsky" title="Marvin Minsky">Marvin Minsky</a>, <i>Computation, Finite and Infinite Machines</i>, Prentice-Hall, Inc., N.J., 1967. See chapter 8, Section 8.2 "The Unsolvability of the Halting Problem." Excellent, i.e. readable, sometimes fun. A classic.</li>
<li><a href="/wiki/Roger_Penrose" title="Roger Penrose">Roger Penrose</a>, <i>The Emperor's New Mind: Concerning computers, Minds and the Laws of Physics</i>, Oxford University Press, Oxford England, 1990 (with corrections). Cf: Chapter 2, "Algorithms and Turing Machines". An overly-complicated presentation (see Davis's paper for a better model), but a thorough presentation of Turing machines and the halting problem, and Church's Lambda Calculus.</li>
<li><a href="/wiki/John_Hopcroft" title="John Hopcroft">John Hopcroft</a> and <a href="/wiki/Jeffrey_Ullman" title="Jeffrey Ullman">Jeffrey Ullman</a>, <i>Introduction to Automata Theory, Languages and Computation</i>, Addison-Wesley, Reading Mass, 1979. See Chapter 7 "Turing Machines." A book centered around the machine-interpretation of "languages", NP-Completeness, etc.</li>
<li><a href="/w/index.php?title=Andrew_Hodges&amp;action=edit" class="new" title="Andrew Hodges">Andrew Hodges</a>, <i>Alan Turing: The Enigma</i>, Simon and Schuster, New York. Cf Chapter "The Spirit of Truth" for a history leading to, and a discussion of, his proof.</li>
<li><a href="/wiki/Constance_Reid" title="Constance Reid">Constance Reid</a>, <i>Hilbert</i>, Copernicus: Springer-Verlag, New York, 1996 (first published 1970). Fascinating history of German mathematics and physics from 1880s through 1930s. Hundreds of names familiar to mathematicians, physicists and engineers appear in its pages. Perhaps marred by no overt references and few footnotes: Reid states her sources were numerous interviews with those who personally knew Hilbert, and Hilbert's letters and papers.</li>
<li><a href="/w/index.php?title=Edward_Beltrami&amp;action=edit" class="new" title="Edward Beltrami">Edward Beltrami</a>, <i>What is Random? Chance and order in mathematics and life</i>, Copernicus: Springer-Verlag, New York, 1999. Nice, gentle read for the mathematically-inclined non-specialist, puts tougher stuff at the end. Has a Turing-machine model in it. Discusses the <a href="/wiki/Chaitin" title="Chaitin">Chaitin</a> contributions.</li>
<li><a href="/wiki/Ernest_Nagel" title="Ernest Nagel">Ernest Nagel</a> and <a href="/wiki/James_R._Newman" title="James R. Newman">James R. Newman</a>, <i>Godel’s Proof</i>, New York University Press, 1958. Wonderful writing about a very difficult subject. For the mathematically-inclined non-specialist. Discusses Gentzen's proof on pages 96-97 and footnotes. Appendices discuss the <a href="/wiki/Peano_Axioms" title="Peano Axioms">Peano Axioms</a> briefly, gently introduce readers to formal logic.</li>
<li><a href="/wiki/Taylor_Booth" title="Taylor Booth">Taylor Booth</a>, <i>Sequential Machines and Automata Theory</i>, Wiley, New York, 1967. Cf Chapter 9, Turing Machines. Difficult book, meant for electrical engineers and technical specialists. Discusses recursion, partial-recursion with reference to Turing Machines, halting problem. Has a <a href="/wiki/Turing_Machine" title="Turing Machine">Turing Machine</a> model in it. References at end of Chapter 9 catch most of the older books (i.e. 1952 until 1967 including authors Martin Davis, F. C. Hennie, H. Hermes, S. C. Kleene, M. Minsky, T. Rado) and various technical papers. See note under Busy-Beaver Programs.</li>
<li><a href="/wiki/Busy_Beaver" title="Busy Beaver">Busy Beaver</a> Programs are described in Scientific American, August 1984, also March 1985 p. 23. A reference in Booth attributes them to Rado, T.(1962), On non-computable functions, Bell Systems Tech. J. 41. Booth also defines Rado's Busy Beaver Problem in problems 3, 4, 5, 6 of Chapter 9, p. 396.</li>
<li><a href="/w/index.php?title=David_Bolter&amp;action=edit" class="new" title="David Bolter">David Bolter</a>, <i>Turing’s Man: Western Culture in the Computer Age</i>, The University of North Carolina Press, Chapel Hill, 1984. For the general reader. May be dated. Has yet another (very simple) Turing Machine model in it.</li>
<li><a href="/wiki/Stephen_Kleene" title="Stephen Kleene">Stephen Kleene</a>, <i>Introduction to Metamathematics</i>, North-Holland, 1952. Chapter XIII ("Computable Functions") includes a discussion of the unsolvability of the halting problem for Turing machines. In a departure from Turing's terminology of circle-free nonhalting machines, Kleene refers instead to machines that "stop", i.e. halt.</li>
</ul>

<!-- 
Pre-expand include size: 6714 bytes
Post-expand include size: 1696 bytes
Template argument size: 1129 bytes
Maximum: 2048000 bytes
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:13668-0!1!0!default!!en!2 and timestamp 20070912073817 -->
<div class="printfooter">
Retrieved from "<a href="http://en.wikipedia.org/wiki/Halting_problem">http://en.wikipedia.org/wiki/Halting_problem</a>"</div>
			<div id="catlinks"><p class='catlinks'><a href="/wiki/Special:Categories" title="Special:Categories">Categories</a>: <span dir='ltr'><a href="/wiki/Category:Mathematical_logic" title="Category:Mathematical logic">Mathematical logic</a></span> | <span dir='ltr'><a href="/wiki/Category:Theory_of_computation" title="Category:Theory of computation">Theory of computation</a></span> | <span dir='ltr'><a href="/wiki/Category:Recursion_theory" title="Category:Recursion theory">Recursion theory</a></span></p></div>			<!-- end content -->
			<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
					 <li id="ca-nstab-main" class="selected"><a href="/wiki/Halting_problem" title="View the content page [c]" accesskey="c">Article</a></li>
					 <li id="ca-talk"><a href="/wiki/Talk:Halting_problem" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
					 <li id="ca-edit"><a href="/w/index.php?title=Halting_problem&amp;action=edit" title="You can edit this page. Please use the preview button before saving. [e]" accesskey="e">Edit this page</a></li>
					 <li id="ca-history"><a href="/w/index.php?title=Halting_problem&amp;action=history" title="Past versions of this page [h]" accesskey="h">History</a></li>
				</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a href="/w/index.php?title=Special:Userlogin&amp;returnto=Halting_problem" title="You are encouraged to log in, it is not mandatory however. [o]" accesskey="o">Sign in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(/images/wiki-en.png);" href="/wiki/Main_Page" title="Visit the Main Page [z]" accesskey="z"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
		<div class='portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-Main-page"><a href="/wiki/Main_Page">Main page</a></li>
				<li id="n-Contents"><a href="/wiki/Wikipedia:Contents">Contents</a></li>
				<li id="n-Featured-content"><a href="/wiki/Wikipedia:Featured_content">Featured content</a></li>
				<li id="n-currentevents"><a href="/wiki/Portal:Current_events" title="Find background information on current events">Current events</a></li>
				<li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random page [x]" accesskey="x">Random article</a></li>
			</ul>
		</div>
	</div>
		<div class='portlet' id='p-interaction'>
		<h5>interaction</h5>
		<div class='pBody'>
			<ul>
				<li id="n-About-Wikipedia"><a href="/wiki/Wikipedia:About">About Wikipedia</a></li>
				<li id="n-portal"><a href="/wiki/Wikipedia:Community_Portal" title="About the project, what you can do, where to find things">Community portal</a></li>
				<li id="n-recentchanges"><a href="/wiki/Special:Recentchanges" title="The list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
				<li id="n-contact"><a href="/wiki/Wikipedia:Contact_us">Contact Wikipedia</a></li>
				<li id="n-sitesupport"><a href="http://wikimediafoundation.org/wiki/Fundraising" title="Support us">Donate to Wikipedia</a></li>
				<li id="n-help"><a href="/wiki/Help:Contents" title="Guidance on how to use and edit Wikipedia">Help</a></li>
			</ul>
		</div>
	</div>
		<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/wiki/Special:Search" id="searchform"><div>
				<input id="searchInput" name="search" type="text" title="Search Wikipedia [f]" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" />
			</div></form>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="/wiki/Special:Whatlinkshere/Halting_problem" title="List of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="/wiki/Special:Recentchangeslinked/Halting_problem" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
<li id="t-upload"><a href="/wiki/Wikipedia:Upload" title="Upload images or media files [u]" accesskey="u">Upload file</a></li>
<li id="t-specialpages"><a href="/wiki/Special:Specialpages" title="List of all special pages [q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="/w/index.php?title=Halting_problem&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>				<li id="t-permalink"><a href="/w/index.php?title=Halting_problem&amp;oldid=156685701" title="Permanent link to this version of the page">Permanent link</a></li><li id="t-cite"><a href="/w/index.php?title=Special:Cite&amp;page=Halting_problem&amp;id=156685701">Cite this article</a></li>			</ul>
		</div>
	</div>
	<div id="p-lang" class="portlet">
		<h5>In other languages</h5>
		<div class="pBody">
			<ul>
				<li class="interwiki-ca"><a href="http://ca.wikipedia.org/wiki/Problema_de_la_parada">Català</a></li>
				<li class="interwiki-cs"><a href="http://cs.wikipedia.org/wiki/Probl%C3%A9m_zastaven%C3%AD">Česky</a></li>
				<li class="interwiki-de"><a href="http://de.wikipedia.org/wiki/Halteproblem">Deutsch</a></li>
				<li class="interwiki-es"><a href="http://es.wikipedia.org/wiki/Problema_de_la_parada">Español</a></li>
				<li class="interwiki-fa"><a href="http://fa.wikipedia.org/wiki/%D9%85%D8%B3%D8%A7%D9%84%D9%87_%D8%AA%D9%88%D9%82%D9%81">فارسی</a></li>
				<li class="interwiki-fr"><a href="http://fr.wikipedia.org/wiki/Probl%C3%A8me_de_l%27arr%C3%AAt">Français</a></li>
				<li class="interwiki-ko"><a href="http://ko.wikipedia.org/wiki/%EC%A0%95%EC%A7%80_%EB%AC%B8%EC%A0%9C">한국어</a></li>
				<li class="interwiki-hr"><a href="http://hr.wikipedia.org/wiki/Problem_zaustavljanja">Hrvatski</a></li>
				<li class="interwiki-it"><a href="http://it.wikipedia.org/wiki/Problema_della_fermata">Italiano</a></li>
				<li class="interwiki-he"><a href="http://he.wikipedia.org/wiki/%D7%91%D7%A2%D7%99%D7%99%D7%AA_%D7%94%D7%A2%D7%A6%D7%99%D7%A8%D7%94">עברית</a></li>
				<li class="interwiki-nl"><a href="http://nl.wikipedia.org/wiki/Stopprobleem">Nederlands</a></li>
				<li class="interwiki-ja"><a href="http://ja.wikipedia.org/wiki/%E3%83%81%E3%83%A5%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0%E3%83%9E%E3%82%B7%E3%83%B3%E3%81%AE%E5%81%9C%E6%AD%A2%E5%95%8F%E9%A1%8C">日本語</a></li>
				<li class="interwiki-pl"><a href="http://pl.wikipedia.org/wiki/Problem_stopu">Polski</a></li>
				<li class="interwiki-pt"><a href="http://pt.wikipedia.org/wiki/Problema_da_parada">Português</a></li>
				<li class="interwiki-ru"><a href="http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B0_%D0%BE%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%B0">Русский</a></li>
				<li class="interwiki-fi"><a href="http://fi.wikipedia.org/wiki/Pys%C3%A4htymisongelma">Suomi</a></li>
				<li class="interwiki-sv"><a href="http://sv.wikipedia.org/wiki/Stopproblemet">Svenska</a></li>
				<li class="interwiki-th"><a href="http://th.wikipedia.org/wiki/%E0%B8%9B%E0%B8%B1%E0%B8%8D%E0%B8%AB%E0%B8%B2%E0%B8%81%E0%B8%B2%E0%B8%A3%E0%B8%A2%E0%B8%B8%E0%B8%95%E0%B8%B4%E0%B8%81%E0%B8%B2%E0%B8%A3%E0%B8%97%E0%B8%B3%E0%B8%87%E0%B8%B2%E0%B8%99">ไทย</a></li>
				<li class="interwiki-zh"><a href="http://zh.wikipedia.org/wiki/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98">中文</a></li>
			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="/skins-1.5/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>
				<div id="f-copyrightico"><a href="http://wikimediafoundation.org/"><img src="/images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>
			<ul id="f-list">
				<li id="lastmod"> This page was last modified 12:49, 9 September 2007.</li>
				<li id="copyright">All text is available under the terms of the <a class='internal' href="/wiki/Wikipedia:Text_of_the_GNU_Free_Documentation_License" title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal' href="/wiki/Wikipedia:Copyrights" title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the <a href="http://www.wikimediafoundation.org">Wikimedia Foundation, Inc</a>., a U.S. registered <a class='internal' href="/wiki/501%28c%29#501.28c.29.283.29" title="501(c)(3)">501(c)(3)</a> <a href="http://wikimediafoundation.org/wiki/Deductibility_of_donations">tax-deductible</a> <a class='internal' href="/wiki/Non-profit_organization" title="Non-profit organization">nonprofit</a> <a href="/wiki/Charitable_organization" title="Charitable organization">charity</a>.<br /></li>
				<li id="privacy"><a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy policy</a></li>
				<li id="about"><a href="/wiki/Wikipedia:About" title="Wikipedia:About">About Wikipedia</a></li>
				<li id="disclaimer"><a href="/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
		
	
		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
</div>
<!-- Served by srv111 in 0.113 secs. --></body></html>
